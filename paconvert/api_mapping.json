{
  "fairscale.nn.model_parallel.initialize.get_model_parallel_rank": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.get_rank",
    "args_list": [
      "group"
    ]
  },
  "fairscale.nn.model_parallel.initialize.get_model_parallel_world_size": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.get_world_size",
    "args_list": [
      "group"
    ]
  },
  "fairscale.nn.model_parallel.initialize.initialize_model_parallel": {
    "Matcher": "FSInitializeModelParallelMatcher",
    "args_list": [
      "model_parallel_size_",
      "pipeline_length",
      "*",
      "model_parallel_backend",
      "pipeline_backend",
      "ddp_backend"
    ],
    "kwargs_change": {
      "model_parallel_backend": "",
      "pipeline_backend": "",
      "ddp_backend": ""
    },
    "min_input_args": 1
  },
  "fairscale.nn.model_parallel.initialize.model_parallel_is_initialized": {
    "Matcher": "FSModelParallelIsInitializedMatcher"
  },
  "fairscale.nn.model_parallel.layers.ColumnParallelLinear": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.fleet.meta_parallel.ColumnParallelLinear",
    "args_list": [
      "in_features",
      "out_features",
      "bias",
      "gather_output",
      "init_method",
      "stride",
      "keep_master_weight_for_test"
    ],
    "unsupport_args": [
      "stride"
    ],
    "kwargs_change": {
      "bias": "has_bias",
      "init_method": "",
      "keep_master_weight_for_test": ""
    },
    "paddle_default_kwargs": {
      "has_bias": "True"
    }
  },
  "fairscale.nn.model_parallel.layers.ParallelEmbedding": {
    "Matcher": "FSParallelEmbeddingMatcher",
    "args_list": [
      "num_embeddings",
      "embedding_dim",
      "padding_idx",
      "norm_type",
      "scale_grad_by_freq",
      "sparse",
      "init_method",
      "keep_master_weight_for_test"
    ],
    "kwargs_change": {
      "init_method": "",
      "keep_master_weight_for_test": ""
    },
    "unsupport_args": [
      "padding_idx",
      "norm_type",
      "scale_grad_by_freq",
      "sparse"
    ]
  },
  "fairscale.nn.model_parallel.layers.RowParallelLinear": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.fleet.meta_parallel.RowParallelLinear",
    "args_list": [
      "in_features",
      "out_features",
      "bias",
      "input_is_parallel",
      "init_method",
      "stride",
      "keep_master_weight_for_test"
    ],
    "unsupport_args": [
      "stride"
    ],
    "kwargs_change": {
      "bias": "has_bias",
      "init_method": "",
      "keep_master_weight_for_test": ""
    },
    "paddle_default_kwargs": {
      "has_bias": "True"
    }
  },
  "flash_attn.flash_attn_interface.flash_attn_func": {
    "Matcher": "FAFlashAttnFuncMatcher",
    "paddle_api": "paddle.nn.functional.flash_attention",
    "args_list": [
      "q",
      "k",
      "v",
      "dropout_p",
      "softmax_scale",
      "causal",
      "window_size",
      "alibi_slopes",
      "deterministic",
      "return_attn_probs"
    ],
    "unsupport_args": [
      "window_size",
      "alibi_slopes",
      "deterministic",
      "return_attn_probs"
    ],
    "kwargs_change": {
      "q": "query",
      "k": "key",
      "v": "value"
    }
  },
  "flash_attn.flash_attn_interface.flash_attn_unpadded_func": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.flash_attn_unpadded",
    "args_list": [
      "q",
      "k",
      "v",
      "cu_seqlens_q",
      "cu_seqlens_k",
      "max_seqlen_q",
      "max_seqlen_k",
      "dropout_p",
      "softmax_scale",
      "casul",
      "window_size",
      "alibi_slopes",
      "deterministic",
      "return_attn_probs"
    ],
    "unsupport_args": [
      "window_size",
      "alibi_slopes",
      "deterministic",
      "return_attn_probs"
    ],
    "kwargs_change": {
      "q": "query",
      "k": "key",
      "v": "value",
      "softmax_scale": "scale"
    }
  },
  "os.environ.get": {
    "Matcher": "OsEnvironGetMatcher",
    "args_list": [
      "key",
      "value"
    ]
  },
  "setuptools.setup": {
    "Matcher": "SetUpMatcher",
    "min_input_args": 0
  },
  "torch.BoolTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.bool"
  },
  "torch.ByteTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.uint8"
  },
  "torch.DoubleTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float64"
  },
  "torch.FloatTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float32"
  },
  "torch.Generator": {
    "Matcher": "GeneratorMatcher",
    "min_input_args": 0,
    "args_list": [
      "device"
    ]
  },
  "torch.HalfTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float16"
  },
  "torch.IntTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int32"
  },
  "torch.LongTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int64"
  },
  "torch.ShortTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int16"
  },
  "torch.Size": {
    "Matcher": "SizeMatcher",
    "paddle_api": "list",
    "min_input_args": 0
  },
  "torch.Tensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.Tensor"
  },
  "torch.Tensor.abs": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.abs",
    "min_input_args": 0
  },
  "torch.Tensor.abs_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.abs_",
    "min_input_args": 0
  },
  "torch.Tensor.add": {
    "Matcher": "TensorAddMatcher",
    "paddle_api": "paddle.Tensor.add",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "alpha"
    ]
  },
  "torch.Tensor.add_": {
    "Matcher": "Num2TensorBinaryWithAlphaMatcher",
    "paddle_api": "paddle.Tensor.add_",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "alpha"
    ]
  },
  "torch.Tensor.addbmm": {
    "Matcher": "AddBmmMatcher",
    "min_input_args": 2,
    "args_list": [
      "batch1",
      "batch2",
      "*",
      "beta",
      "alpha"
    ]
  },
  "torch.Tensor.addbmm_": {},
  "torch.Tensor.addcdiv": {
    "Matcher": "AddCDivMatcher",
    "min_input_args": 2,
    "args_list": [
      "tensor1",
      "tensor2",
      "*",
      "value"
    ]
  },
  "torch.Tensor.addcdiv_": {},
  "torch.Tensor.addcmul": {
    "Matcher": "AddCMulMatcher",
    "min_input_args": 2,
    "args_list": [
      "tensor1",
      "tensor2",
      "*",
      "value"
    ]
  },
  "torch.Tensor.addcmul_": {},
  "torch.Tensor.addmm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.addmm",
    "min_input_args": 2,
    "args_list": [
      "mat1",
      "mat2",
      "*",
      "beta",
      "alpha"
    ],
    "kwargs_change": {
      "mat1": "x",
      "mat2": "y"
    }
  },
  "torch.Tensor.addmm_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.addmm_",
    "min_input_args": 2,
    "args_list": [
      "mat1",
      "mat2",
      "*",
      "alpha",
      "beta"
    ],
    "kwargs_change": {
      "mat1": "x",
      "mat2": "y"
    }
  },
  "torch.Tensor.addmv": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.mm",
    "min_input_args": 2,
    "args_list": [
      "mat",
      "vec",
      "*",
      "beta",
      "alpha"
    ]
  },
  "torch.Tensor.addmv_": {},
  "torch.Tensor.addr": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.outer",
    "min_input_args": 2,
    "args_list": [
      "vec1",
      "vec2",
      "*",
      "beta",
      "alpha"
    ]
  },
  "torch.Tensor.addr_": {},
  "torch.Tensor.adjoint": {
    "Matcher": "AdjointMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.align_as": {},
  "torch.Tensor.align_to": {
    "min_input_args": 0
  },
  "torch.Tensor.all": {
    "Matcher": "TensorToBoolMatcher",
    "paddle_api": "paddle.Tensor.all",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.allclose": {
    "Matcher": "AllcloseMatcher",
    "paddle_api": "paddle.Tensor.allclose",
    "min_input_args": 1,
    "args_list": [
      "other",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.amax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.amax",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.amin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.amin",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.aminmax": {
    "Matcher": "AMinMaxMatcher",
    "min_input_args": 0,
    "args_list": [
      "*",
      "dim",
      "keepdim"
    ]
  },
  "torch.Tensor.angle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.angle",
    "min_input_args": 0
  },
  "torch.Tensor.any": {
    "Matcher": "TensorToBoolMatcher",
    "paddle_api": "paddle.Tensor.any",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.apply_": {},
  "torch.Tensor.arccos": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.acos",
    "min_input_args": 0
  },
  "torch.Tensor.arccos_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.acos_",
    "min_input_args": 0
  },
  "torch.Tensor.arccosh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.acosh",
    "min_input_args": 0
  },
  "torch.Tensor.arccosh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.acosh_",
    "min_input_args": 0
  },
  "torch.Tensor.arcsin": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.arcsin_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.asin_",
    "min_input_args": 0
  },
  "torch.Tensor.arcsinh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.asinh",
    "min_input_args": 0
  },
  "torch.Tensor.arcsinh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.asinh_",
    "min_input_args": 0
  },
  "torch.Tensor.arctan": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.arctan2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.atan2",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.arctan2_": {},
  "torch.Tensor.arctan_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.atan_",
    "min_input_args": 0
  },
  "torch.Tensor.arctanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.atanh",
    "min_input_args": 0
  },
  "torch.Tensor.arctanh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.atanh_",
    "min_input_args": 0
  },
  "torch.Tensor.argmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.argmax",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.argmin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.argmin",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.argsort": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.argsort",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "descending"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.argwhere": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nonzero",
    "min_input_args": 0
  },
  "torch.Tensor.as_strided": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.as_strided",
    "min_input_args": 2,
    "args_list": [
      "size",
      "stride",
      "storage_offset"
    ],
    "kwargs_change": {
      "size": "shape",
      "storage_offset": "offset"
    }
  },
  "torch.Tensor.as_subclass": {},
  "torch.Tensor.backward": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.backward",
    "min_input_args": 0,
    "args_list": [
      "gradient",
      "retain_graph",
      "create_graph",
      "input"
    ],
    "kwargs_change": {
      "gradient": "grad_tensor"
    },
    "unsupport_args": [
      "create_graph",
      "input"
    ]
  },
  "torch.Tensor.baddbmm": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.bmm",
    "min_input_args": 2,
    "args_list": [
      "batch1",
      "batch2",
      "*",
      "beta",
      "alpha"
    ]
  },
  "torch.Tensor.baddbmm_": {},
  "torch.Tensor.bernoulli": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bernoulli",
    "min_input_args": 0,
    "args_list": [
      "p",
      "*",
      "generator"
    ],
    "unsupport_args": [
      "p"
    ]
  },
  "torch.Tensor.bernoulli_": {},
  "torch.Tensor.bfloat16": {
    "Matcher": "TensorBF16Matcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.bincount": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bincount",
    "min_input_args": 0,
    "args_list": [
      "weights",
      "minlength"
    ]
  },
  "torch.Tensor.bitwise_and": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_and",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bitwise_and_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_and_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bitwise_left_shift": {},
  "torch.Tensor.bitwise_left_shift_": {},
  "torch.Tensor.bitwise_not": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_not",
    "min_input_args": 0
  },
  "torch.Tensor.bitwise_not_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_not_",
    "min_input_args": 0
  },
  "torch.Tensor.bitwise_or": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_or",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bitwise_or_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_or_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bitwise_right_shift": {},
  "torch.Tensor.bitwise_right_shift_": {},
  "torch.Tensor.bitwise_xor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_xor",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bitwise_xor_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bitwise_xor_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.bmm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.bmm",
    "min_input_args": 1,
    "args_list": [
      "mat2"
    ],
    "kwargs_change": {
      "mat2": "y"
    }
  },
  "torch.Tensor.bool": {
    "Matcher": "TensorBoolMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.broadcast_to": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.broadcast_to",
    "min_input_args": 1,
    "args_list": [
      "size"
    ],
    "kwargs_change": {
      "size": "shape"
    }
  },
  "torch.Tensor.byte": {
    "Matcher": "TensorByteMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.cauchy_": {},
  "torch.Tensor.cdouble": {
    "Matcher": "TensorCdoubleMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.ceil": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.ceil_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.ceil_",
    "min_input_args": 0
  },
  "torch.Tensor.cfloat": {
    "Matcher": "TensorCfloatMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.chalf": {},
  "torch.Tensor.char": {
    "Matcher": "TensorCharMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.cholesky": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cholesky",
    "min_input_args": 0,
    "args_list": [
      "upper"
    ]
  },
  "torch.Tensor.cholesky_inverse": {
    "Matcher": "CholeskyInverseMatcher",
    "min_input_args": 0,
    "args_list": [
      "upper"
    ]
  },
  "torch.Tensor.cholesky_solve": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cholesky_solve",
    "min_input_args": 1,
    "args_list": [
      "input2",
      "upper"
    ],
    "kwargs_change": {
      "input2": "y"
    }
  },
  "torch.Tensor.chunk": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.chunk",
    "min_input_args": 1,
    "args_list": [
      "chunks",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.clamp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.clip",
    "min_input_args": 1,
    "args_list": [
      "min",
      "max"
    ]
  },
  "torch.Tensor.clamp_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.clip_",
    "min_input_args": 1,
    "args_list": [
      "min",
      "max"
    ]
  },
  "torch.Tensor.clip": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "min",
      "max"
    ]
  },
  "torch.Tensor.clip_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.clip_",
    "min_input_args": 1,
    "args_list": [
      "min",
      "max"
    ]
  },
  "torch.Tensor.clone": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.clone",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.coalesce": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.coalesce",
    "min_input_args": 0
  },
  "torch.Tensor.conj": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.conj_physical": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.conj",
    "min_input_args": 0
  },
  "torch.Tensor.conj_physical_": {},
  "torch.Tensor.contiguous": {
    "Matcher": "TensorSkipMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.copy_": {
    "Matcher": "TensorCopy_Matcher",
    "paddle_api": "paddle.assign",
    "min_input_args": 1,
    "args_list": [
      "other",
      "non_blocking"
    ],
    "kwargs_change": {
      "non_blocking": ""
    }
  },
  "torch.Tensor.copysign": {},
  "torch.Tensor.copysign_": {},
  "torch.Tensor.corrcoef": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.corrcoef",
    "min_input_args": 0
  },
  "torch.Tensor.cos": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cos",
    "min_input_args": 0
  },
  "torch.Tensor.cos_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cos_",
    "min_input_args": 0
  },
  "torch.Tensor.cosh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cosh",
    "min_input_args": 0
  },
  "torch.Tensor.cosh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cosh_",
    "min_input_args": 0
  },
  "torch.Tensor.count_nonzero": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.count_nonzero",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.cov": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cov",
    "min_input_args": 0,
    "args_list": [
      "*",
      "correction",
      "fweights",
      "aweights"
    ],
    "kwargs_change": {
      "correction": "ddof"
    }
  },
  "torch.Tensor.cpu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cpu",
    "min_input_args": 0
  },
  "torch.Tensor.cross": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cross",
    "min_input_args": 1,
    "args_list": [
      "other",
      "dim"
    ],
    "kwargs_change": {
      "other": "y",
      "dim": "axis"
    }
  },
  "torch.Tensor.cuda": {
    "Matcher": "TensorCudaMatcher",
    "paddle_api": "paddle.Tensor.cuda",
    "min_input_args": 0,
    "args_list": [
      "device",
      "non_blocking",
      "memory_format"
    ],
    "kwargs_change": {
      "device": "device_id",
      "memory_format": ""
    }
  },
  "torch.Tensor.cummax": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.Tensor.cummax",
    "min_input_args": 1,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.cummin": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.Tensor.cummin",
    "min_input_args": 1,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.cumprod": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "dim",
      "*",
      "dtype"
    ]
  },
  "torch.Tensor.cumprod_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cumprod_",
    "args_list": [
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    },
    "min_input_args": 1
  },
  "torch.Tensor.cumsum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cumsum",
    "min_input_args": 1,
    "args_list": [
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.Tensor.cumsum_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.cumsum_",
    "args_list": [
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    },
    "min_input_args": 1
  },
  "torch.Tensor.data_ptr": {},
  "torch.Tensor.deg2rad": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.dense_dim": {},
  "torch.Tensor.dequantize": {},
  "torch.Tensor.det": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.det"
  },
  "torch.Tensor.detach": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.detach",
    "min_input_args": 0
  },
  "torch.Tensor.detach_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.detach_"
  },
  "torch.Tensor.diag": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.diag",
    "min_input_args": 0,
    "args_list": [
      "diagonal"
    ],
    "kwargs_change": {
      "diagonal": "offset"
    }
  },
  "torch.Tensor.diag_embed": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.diag_embed",
    "min_input_args": 0,
    "args_list": [
      "offset",
      "dim1",
      "dim2"
    ]
  },
  "torch.Tensor.diagflat": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.diagflat",
    "min_input_args": 0,
    "args_list": [
      "offset"
    ]
  },
  "torch.Tensor.diagonal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.diagonal",
    "min_input_args": 0,
    "args_list": [
      "offset",
      "dim1",
      "dim2"
    ],
    "kwargs_change": {
      "dim1": "axis1",
      "dim2": "axis2"
    }
  },
  "torch.Tensor.diagonal_scatter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.diagonal_scatter",
    "min_input_args": 1,
    "args_list": [
      "src",
      "offset",
      "dim1",
      "dim2"
    ],
    "kwargs_change": {
      "src": "y",
      "dim1": "axis1",
      "dim2": "axis2"
    }
  },
  "torch.Tensor.diff": {
    "Matcher": "DiffMatcher",
    "paddle_api": "paddle.Tensor.diff",
    "min_input_args": 0,
    "args_list": [
      "n",
      "dim",
      "prepend",
      "append"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.digamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.digamma",
    "min_input_args": 0
  },
  "torch.Tensor.digamma_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.digamma_",
    "min_input_args": 0
  },
  "torch.Tensor.dim": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.dim",
    "min_input_args": 0
  },
  "torch.Tensor.dist": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.dist",
    "min_input_args": 1,
    "args_list": [
      "other",
      "p"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.divide": {
    "Matcher": "TensorDivideMatcher",
    "paddle_api": "paddle.Tensor.divide",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "rounding_mode"
    ]
  },
  "torch.Tensor.divide_": {
    "Matcher": "TensorDivideWithRoundingModeMatcher",
    "paddle_api": "paddle.Tensor.divide_",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "rounding_mode"
    ]
  },
  "torch.Tensor.dot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.dot",
    "min_input_args": 1,
    "args_list": [
      "tensor"
    ],
    "kwargs_change": {
      "tensor": "y"
    }
  },
  "torch.Tensor.double": {
    "Matcher": "TensorDoubleMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.dsplit": {},
  "torch.Tensor.eig": {
    "min_input_args": 0
  },
  "torch.Tensor.element_size": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.element_size",
    "min_input_args": 0
  },
  "torch.Tensor.eq": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.equal",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.eq_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.equal_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.equal": {
    "Matcher": "EqualMatcher",
    "paddle_api": "paddle.Tensor.equal_all",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.erf": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.erf",
    "min_input_args": 0
  },
  "torch.Tensor.erf_": {
    "Matcher": "TensorFunc2PaddleFunc",
    "paddle_api": "paddle.erf_",
    "min_input_args": 0
  },
  "torch.Tensor.erfc": {
    "Matcher": "ErfCMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.erfc_": {},
  "torch.Tensor.erfinv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.erfinv",
    "min_input_args": 0
  },
  "torch.Tensor.erfinv_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.erfinv_",
    "min_input_args": 0
  },
  "torch.Tensor.exp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.exp",
    "min_input_args": 0
  },
  "torch.Tensor.exp_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.exp_",
    "min_input_args": 0
  },
  "torch.Tensor.expand": {
    "Matcher": "TensorExpandMatcher",
    "paddle_api": "paddle.Tensor.expand"
  },
  "torch.Tensor.expand_as": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.expand_as",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.expm1": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.expm1_": {
    "Matcher": "TensorFunc2PaddleFunc",
    "paddle_api": "paddle.expm1_",
    "min_input_args": 0
  },
  "torch.Tensor.exponential_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.exponential_",
    "min_input_args": 0,
    "args_list": [
      "lambd",
      "*",
      "generator"
    ],
    "kwargs_change": {
      "lambd": "lam"
    }
  },
  "torch.Tensor.fill_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.fill_",
    "min_input_args": 1,
    "args_list": [
      "value"
    ]
  },
  "torch.Tensor.fill_diagonal_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.fill_diagonal_",
    "min_input_args": 1,
    "args_list": [
      "fill_value",
      "wrap"
    ],
    "kwargs_change": {
      "fill_value": "value"
    }
  },
  "torch.Tensor.fix": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.trunc",
    "min_input_args": 0
  },
  "torch.Tensor.fix_": {},
  "torch.Tensor.flatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.flatten",
    "min_input_args": 0,
    "args_list": [
      "start_dim",
      "end_dim"
    ],
    "kwargs_change": {
      "start_dim": "start_axis",
      "end_dim": "stop_axis"
    }
  },
  "torch.Tensor.flip": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.flip",
    "min_input_args": 1,
    "args_list": [
      "dims"
    ],
    "kwargs_change": {
      "dims": "axis"
    }
  },
  "torch.Tensor.fliplr": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.flip",
    "paddle_default_kwargs": {
      "axis": 1
    },
    "min_input_args": 0
  },
  "torch.Tensor.flipud": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.flip",
    "paddle_default_kwargs": {
      "axis": 0
    },
    "min_input_args": 0
  },
  "torch.Tensor.float": {
    "Matcher": "TensorFloatMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.float_power": {
    "Matcher": "FloatPowerMatcher",
    "min_input_args": 1,
    "args_list": [
      "exponent"
    ]
  },
  "torch.Tensor.float_power_": {
    "Matcher": "FloatPowerInplaceMatcher",
    "min_input_args": 1,
    "args_list": [
      "exponent"
    ]
  },
  "torch.Tensor.floor": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.floor_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.floor_",
    "min_input_args": 0
  },
  "torch.Tensor.floor_divide": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.floor_divide",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.floor_divide_": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.floor_divide_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.fmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.fmax",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.fmin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.fmin",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.fmod": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.mod",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.fmod_": {},
  "torch.Tensor.frac": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.frac",
    "min_input_args": 0
  },
  "torch.Tensor.frac_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.frac_",
    "min_input_args": 0
  },
  "torch.Tensor.frexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.frexp",
    "min_input_args": 0
  },
  "torch.Tensor.gather": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.take_along_axis",
    "min_input_args": 2,
    "args_list": [
      "dim",
      "index"
    ],
    "kwargs_change": {
      "dim": "axis",
      "index": "indices"
    }
  },
  "torch.Tensor.gcd": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.gcd",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.gcd_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.gcd_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.geometric_": {},
  "torch.Tensor.geqrf": {},
  "torch.Tensor.ger": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.outer",
    "min_input_args": 1,
    "args_list": [
      "vec2"
    ],
    "kwargs_change": {
      "vec2": "y"
    }
  },
  "torch.Tensor.get_device": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.place.gpu_device_id",
    "min_input_args": 0
  },
  "torch.Tensor.greater": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.greater_than",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.greater_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.greater_than_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.greater_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.greater_equal",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.greater_equal_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.greater_equal_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.half": {
    "Matcher": "TensorFP16Matcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.hardshrink": {
    "Matcher": "TensorFunc2PaddleFunc",
    "paddle_api": "paddle.nn.functional.hardshrink",
    "min_input_args": 0,
    "args_list": [
      "lambd"
    ],
    "kwargs_change": {
      "lambd": "threshold"
    }
  },
  "torch.Tensor.heaviside": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.heaviside",
    "min_input_args": 1,
    "args_list": [
      "values"
    ],
    "kwargs_change": {
      "values": "y"
    }
  },
  "torch.Tensor.histc": {
    "Matcher": "HistcMatcher",
    "paddle_api": "paddle.Tensor.histogram",
    "min_input_args": 0,
    "args_list": [
      "bins",
      "min",
      "max"
    ]
  },
  "torch.Tensor.histogram": {},
  "torch.Tensor.hsplit": {},
  "torch.Tensor.hypot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.hypot",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.hypot_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.hypot_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.i0": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.i0",
    "min_input_args": 0
  },
  "torch.Tensor.i0_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.i0_",
    "min_input_args": 0
  },
  "torch.Tensor.igamma": {},
  "torch.Tensor.igamma_": {},
  "torch.Tensor.igammac": {},
  "torch.Tensor.igammac_": {},
  "torch.Tensor.index_add": {
    "Matcher": "IndexAddMatcher",
    "paddle_api": "paddle.Tensor.index_add",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "source",
      "*",
      "alpha"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.index_add_": {
    "Matcher": "IndexAddMatcher",
    "paddle_api": "paddle.Tensor.index_add_",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "source",
      "*",
      "alpha"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.index_copy": {},
  "torch.Tensor.index_copy_": {
    "Matcher": "TensorIndexCopyMatcher",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "source"
    ]
  },
  "torch.Tensor.index_fill": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.index_fill",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "value"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.index_fill_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.index_fill_",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "value"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.index_put": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.index_put",
    "min_input_args": 2,
    "args_list": [
      "indices",
      "values",
      "accumulate"
    ],
    "kwargs_change": {
      "values": "value"
    }
  },
  "torch.Tensor.index_put_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.index_put_",
    "min_input_args": 2,
    "args_list": [
      "indices",
      "values",
      "accumulate"
    ],
    "kwargs_change": {
      "values": "value"
    }
  },
  "torch.Tensor.index_reduce": {},
  "torch.Tensor.index_reduce_": {},
  "torch.Tensor.index_select": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.index_select",
    "min_input_args": 2,
    "args_list": [
      "dim",
      "index"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.indices": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.indices",
    "min_input_args": 0
  },
  "torch.Tensor.inner": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.inner",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.int": {
    "Matcher": "TensorIntMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.int_repr": {},
  "torch.Tensor.inverse": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.inverse",
    "min_input_args": 0
  },
  "torch.Tensor.is_coalesced": {},
  "torch.Tensor.is_complex": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.is_complex",
    "min_input_args": 0
  },
  "torch.Tensor.is_conj": {},
  "torch.Tensor.is_contiguous": {
    "Matcher": "SetTrueMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.is_floating_point": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.is_floating_point",
    "min_input_args": 0
  },
  "torch.Tensor.is_inference": {},
  "torch.Tensor.is_pinned": {
    "Matcher": "Is_PinnedMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.is_set_to": {},
  "torch.Tensor.is_shared": {
    "min_input_args": 0
  },
  "torch.Tensor.is_signed": {
    "Matcher": "TensorIsSignedMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.isclose": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.isclose",
    "min_input_args": 1,
    "args_list": [
      "other",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.isfinite": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.isfinite",
    "min_input_args": 0
  },
  "torch.Tensor.isinf": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.isinf",
    "min_input_args": 0
  },
  "torch.Tensor.isnan": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.isnan",
    "min_input_args": 0
  },
  "torch.Tensor.isneginf": {},
  "torch.Tensor.isposinf": {},
  "torch.Tensor.isreal": {},
  "torch.Tensor.istft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.istft",
    "min_input_args": 1,
    "args_list": [
      "n_fft",
      "hop_length",
      "win_length",
      "window",
      "center",
      "normalized",
      "onesided",
      "length",
      "return_complex"
    ]
  },
  "torch.Tensor.item": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.kthvalue": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.kthvalue",
    "min_input_args": 1,
    "args_list": [
      "k",
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.lcm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lcm",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.lcm_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lcm_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.ldexp": {
    "Matcher": "LdExpMatcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.ldexp_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.ldexp_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.lerp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lerp",
    "min_input_args": 2,
    "args_list": [
      "end",
      "weight"
    ],
    "kwargs_change": {
      "end": "y"
    }
  },
  "torch.Tensor.lerp_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lerp_",
    "min_input_args": 2,
    "args_list": [
      "end",
      "weight"
    ],
    "kwargs_change": {
      "end": "y"
    }
  },
  "torch.Tensor.less": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.less_than",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.less_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.less_than_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.less_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.less_equal",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.less_equal_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.less_equal_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.lgamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lgamma",
    "min_input_args": 0
  },
  "torch.Tensor.lgamma_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lgamma_",
    "min_input_args": 0
  },
  "torch.Tensor.log": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log",
    "min_input_args": 0
  },
  "torch.Tensor.log10": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log10",
    "min_input_args": 0
  },
  "torch.Tensor.log10_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log10_",
    "min_input_args": 0
  },
  "torch.Tensor.log1p": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.log1p_": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.log2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log2",
    "min_input_args": 0
  },
  "torch.Tensor.log2_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log2_",
    "min_input_args": 0
  },
  "torch.Tensor.log_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.log_",
    "min_input_args": 0
  },
  "torch.Tensor.log_normal_": {},
  "torch.Tensor.logaddexp": {
    "Matcher": "LogAddExpMatcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.logaddexp2": {
    "Matcher": "LogAddExp2Matcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.logcumsumexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logcumsumexp",
    "min_input_args": 1,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.logdet": {
    "Matcher": "LogDetMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.logical_and": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logical_and",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logical_and_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.logical_and_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logical_not": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logical_not",
    "min_input_args": 0
  },
  "torch.Tensor.logical_not_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.logical_not_",
    "min_input_args": 0
  },
  "torch.Tensor.logical_or": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logical_or",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logical_or_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.logical_or_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logical_xor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logical_xor",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logical_xor_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.logical_xor_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.logit": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logit",
    "min_input_args": 0,
    "args_list": [
      "eps"
    ]
  },
  "torch.Tensor.logit_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logit_",
    "min_input_args": 0,
    "args_list": [
      "eps"
    ]
  },
  "torch.Tensor.logsumexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.logsumexp",
    "min_input_args": 1,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.long": {
    "Matcher": "TensorLongMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.lstsq": {
    "min_input_args": 1
  },
  "torch.Tensor.lu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.lu",
    "min_input_args": 0,
    "args_list": [
      "pivot",
      "get_infos"
    ]
  },
  "torch.Tensor.lu_solve": {},
  "torch.Tensor.map_": {},
  "torch.Tensor.masked_fill": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.masked_fill",
    "min_input_args": 2,
    "args_list": [
      "mask",
      "value"
    ]
  },
  "torch.Tensor.masked_fill_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.masked_fill_",
    "min_input_args": 2,
    "args_list": [
      "mask",
      "value"
    ]
  },
  "torch.Tensor.masked_scatter": {},
  "torch.Tensor.masked_scatter_": {},
  "torch.Tensor.masked_select": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.masked_select",
    "min_input_args": 1,
    "args_list": [
      "mask"
    ]
  },
  "torch.Tensor.matmul": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.matmul",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.matrix_exp": {},
  "torch.Tensor.matrix_power": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.matrix_power",
    "min_input_args": 1,
    "args_list": [
      "n"
    ]
  },
  "torch.Tensor.max": {
    "Matcher": "TensorMaxMinMatcher",
    "paddle_api": "paddle.Tensor.max",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "other"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.maximum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.maximum",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.mean": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.mean",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.median": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.median",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    },
    "unsupport_args": [
      "dim"
    ]
  },
  "torch.Tensor.min": {
    "Matcher": "TensorMaxMinMatcher",
    "paddle_api": "paddle.Tensor.min",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "other"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.minimum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.minimum",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.mm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.mm",
    "min_input_args": 1,
    "args_list": [
      "mat2"
    ]
  },
  "torch.Tensor.mode": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.mode",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.moveaxis": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.moveaxis",
    "min_input_args": 2,
    "args_list": [
      "source",
      "destination"
    ]
  },
  "torch.Tensor.movedim": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.moveaxis",
    "min_input_args": 2,
    "args_list": [
      "source",
      "destination"
    ]
  },
  "torch.Tensor.msort": {
    "Matcher": "MSortMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.multinomial": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.multinomial",
    "min_input_args": 1,
    "args_list": [
      "num_samples",
      "replacement",
      "*",
      "generator"
    ]
  },
  "torch.Tensor.multiply": {
    "Matcher": "TensorMultiplyMatcher",
    "paddle_api": "paddle.Tensor.multiply",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.multiply_": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.multiply_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.mv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.mv",
    "min_input_args": 1,
    "args_list": [
      "vec"
    ]
  },
  "torch.Tensor.mvlgamma": {},
  "torch.Tensor.mvlgamma_": {},
  "torch.Tensor.nan_to_num": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nan_to_num",
    "min_input_args": 0,
    "args_list": [
      "nan",
      "posinf",
      "neginf"
    ]
  },
  "torch.Tensor.nan_to_num_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nan_to_num_",
    "min_input_args": 0,
    "args_list": [
      "nan",
      "posinf",
      "neginf"
    ]
  },
  "torch.Tensor.nanmean": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nanmean",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.nanmedian": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nanmedian",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis"
    },
    "unsupport_args": [
      "dim"
    ]
  },
  "torch.Tensor.nanquantile": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nanquantile",
    "min_input_args": 1,
    "args_list": [
      "q",
      "dim",
      "keepdim",
      "*",
      "interpolation"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.nansum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nansum",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.Tensor.narrow": {
    "Matcher": "NarrowMatcher",
    "paddle_api": "paddle.slice",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "start",
      "length"
    ]
  },
  "torch.Tensor.narrow_copy": {
    "Matcher": "NarrowCopyMatcher",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "start",
      "length"
    ]
  },
  "torch.Tensor.ndimension": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.ndimension",
    "min_input_args": 0
  },
  "torch.Tensor.neg": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.neg",
    "min_input_args": 0
  },
  "torch.Tensor.neg_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.neg_",
    "min_input_args": 0
  },
  "torch.Tensor.negative": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.neg",
    "min_input_args": 0
  },
  "torch.Tensor.negative_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.neg_",
    "min_input_args": 0
  },
  "torch.Tensor.nelement": {
    "Matcher": "Func2Attribute",
    "paddle_api": "paddle.Tensor.size",
    "min_input_args": 0
  },
  "torch.Tensor.new_empty": {
    "Matcher": "TensorNew_Matcher",
    "paddle_api": "paddle.empty",
    "min_input_args": 1,
    "args_list": [
      "size",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "layout",
      "pin_memory"
    ]
  },
  "torch.Tensor.new_full": {
    "Matcher": "TensorNewFullMatcher",
    "paddle_api": "paddle.full",
    "min_input_args": 2,
    "args_list": [
      "size",
      "fill_value",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "layout",
      "pin_memory"
    ]
  },
  "torch.Tensor.new_ones": {
    "Matcher": "TensorNew_Matcher",
    "paddle_api": "paddle.ones",
    "min_input_args": 1,
    "args_list": [
      "size",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "layout",
      "pin_memory"
    ]
  },
  "torch.Tensor.new_tensor": {
    "Matcher": "TensorNewTensorMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "data",
      "*",
      "dtype",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "device": "place"
    }
  },
  "torch.Tensor.new_zeros": {
    "Matcher": "TensorNew_Matcher",
    "paddle_api": "paddle.zeros",
    "min_input_args": 1,
    "args_list": [
      "size",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "layout",
      "pin_memory"
    ]
  },
  "torch.Tensor.nextafter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.nextafter",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.nextafter_": {},
  "torch.Tensor.nonzero": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0,
    "args_list": [
      "*",
      "as_tuple"
    ]
  },
  "torch.Tensor.norm": {
    "Matcher": "NormMatcher",
    "paddle_api": "paddle.Tensor.norm",
    "min_input_args": 0,
    "args_list": [
      "p",
      "dim",
      "keepdim",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.normal_": {},
  "torch.Tensor.not_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.not_equal",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.not_equal_": {
    "Matcher": "TensorInplaceReserveTypeMatcher",
    "paddle_api": "paddle.Tensor.not_equal_",
    "min_input_args": 1,
    "convert_tensor": [
      "other"
    ],
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.numel": {
    "Matcher": "Func2Attribute",
    "paddle_api": "paddle.Tensor.size",
    "min_input_args": 0
  },
  "torch.Tensor.numpy": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.numpy",
    "min_input_args": 0,
    "args_list": [
      "*",
      "force"
    ],
    "kwargs_change": {
      "force": ""
    }
  },
  "torch.Tensor.orgqr": {},
  "torch.Tensor.ormqr": {},
  "torch.Tensor.outer": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.outer",
    "min_input_args": 1,
    "args_list": [
      "vec2"
    ],
    "kwargs_change": {
      "vec2": "y"
    }
  },
  "torch.Tensor.permute": {
    "Matcher": "TensorPermuteMatcher",
    "paddle_api": "paddle.Tensor.transpose",
    "min_input_args": 1,
    "args_list": [
      "*dims"
    ]
  },
  "torch.Tensor.pin_memory": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.pin_memory",
    "min_input_args": 0
  },
  "torch.Tensor.pinverse": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.pinv",
    "min_input_args": 0
  },
  "torch.Tensor.polygamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.polygamma",
    "min_input_args": 1,
    "args_list": [
      "n"
    ]
  },
  "torch.Tensor.polygamma_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.polygamma_",
    "min_input_args": 1,
    "args_list": [
      "n"
    ]
  },
  "torch.Tensor.positive": {},
  "torch.Tensor.pow": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.pow",
    "min_input_args": 1,
    "args_list": [
      "exponent"
    ],
    "kwargs_change": {
      "exponent": "y"
    }
  },
  "torch.Tensor.pow_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.pow_",
    "min_input_args": 1,
    "args_list": [
      "exponent"
    ],
    "kwargs_change": {
      "exponent": "y"
    }
  },
  "torch.Tensor.prod": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.prod",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.Tensor.put_": {},
  "torch.Tensor.q_per_channel_axis": {},
  "torch.Tensor.q_per_channel_scales": {},
  "torch.Tensor.q_per_channel_zero_points": {},
  "torch.Tensor.q_scale": {},
  "torch.Tensor.q_zero_point": {},
  "torch.Tensor.qr": {
    "Matcher": "QrMatcher",
    "paddle_api": "paddle.Tensor.qr",
    "min_input_args": 0,
    "args_list": [
      "some"
    ]
  },
  "torch.Tensor.qscheme": {},
  "torch.Tensor.quantile": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.quantile",
    "min_input_args": 1,
    "args_list": [
      "q",
      "dim",
      "keepdim",
      "*",
      "interpolation"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.rad2deg": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.random_": {},
  "torch.Tensor.ravel": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.flatten",
    "min_input_args": 0
  },
  "torch.Tensor.reciprocal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.reciprocal",
    "min_input_args": 0
  },
  "torch.Tensor.reciprocal_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.reciprocal_",
    "min_input_args": 0
  },
  "torch.Tensor.record_stream": {},
  "torch.Tensor.refine_names": {
    "min_input_args": 0
  },
  "torch.Tensor.register_hook": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.register_hook",
    "min_input_args": 1,
    "args_list": [
      "hook"
    ]
  },
  "torch.Tensor.remainder": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.remainder",
    "min_input_args": 1,
    "args_list": [
      "divisor"
    ],
    "kwargs_change": {
      "divisor": "y"
    }
  },
  "torch.Tensor.remainder_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.remainder_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.rename": {
    "Matcher": "TensorRenameMatcher",
    "min_input_args": 0,
    "args_list": [
      "*names",
      "**rename_map"
    ]
  },
  "torch.Tensor.rename_": {
    "min_input_args": 0
  },
  "torch.Tensor.renorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.renorm",
    "min_input_args": 3,
    "args_list": [
      "p",
      "dim",
      "maxnorm"
    ],
    "kwargs_change": {
      "dim": "axis",
      "maxnorm": "max_norm"
    }
  },
  "torch.Tensor.renorm_": {
    "Matcher": "GenericMatcher",
    "min_input_args": 3,
    "paddle_api": "paddle.Tensor.renorm_",
    "args_list": [
      "p",
      "dim",
      "maxnorm"
    ],
    "kwargs_change": {
      "dim": "axis",
      "maxnorm": "max_norm"
    }
  },
  "torch.Tensor.repeat": {
    "Matcher": "TensorRepeatMatcher",
    "paddle_api": "paddle.Tensor.tile",
    "min_input_args": 1,
    "args_list": [
      "*repeats"
    ]
  },
  "torch.Tensor.repeat_interleave": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.repeat_interleave",
    "min_input_args": 1,
    "args_list": [
      "repeats",
      "dim",
      "*",
      "output_size"
    ],
    "kwargs_change": {
      "dim": "axis",
      "output_size": ""
    }
  },
  "torch.Tensor.requires_grad_": {
    "Matcher": "TensorRequiresGrad_Matcher",
    "min_input_args": 0,
    "args_list": [
      "requires_grad"
    ]
  },
  "torch.Tensor.reshape": {
    "Matcher": "TensorReshapeMatcher",
    "paddle_api": "paddle.Tensor.reshape",
    "min_input_args": 1,
    "args_list": [
      "*shape"
    ]
  },
  "torch.Tensor.reshape_as": {
    "Matcher": "TensorReshape_asMatcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.resize_": {},
  "torch.Tensor.resize_as_": {
    "Matcher": "TensorResize_as_Matcher",
    "min_input_args": 1,
    "args_list": [
      "the_template",
      "*",
      "memory_format"
    ],
    "kwargs_change": {
      "memory_format": ""
    }
  },
  "torch.Tensor.resolve_conj": {},
  "torch.Tensor.resolve_neg": {},
  "torch.Tensor.retain_grad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.retain_grads",
    "min_input_args": 0
  },
  "torch.Tensor.retains_grad": {},
  "torch.Tensor.roll": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.roll",
    "min_input_args": 1,
    "args_list": [
      "shifts",
      "dims"
    ],
    "kwargs_change": {
      "dims": "axis"
    }
  },
  "torch.Tensor.rot90": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.rot90",
    "min_input_args": 0,
    "args_list": [
      "k",
      "dims"
    ],
    "kwargs_change": {
      "dims": "axes"
    }
  },
  "torch.Tensor.round": {
    "Matcher": "TensorRoundMatcher",
    "paddle_api": "paddle.Tensor.round",
    "min_input_args": 0,
    "args_list": [
      "*",
      "decimals"
    ]
  },
  "torch.Tensor.round_": {
    "Matcher": "TensorRound_Matcher",
    "paddle_api": "paddle.Tensor.round_",
    "min_input_args": 0,
    "args_list": [
      "*",
      "decimals"
    ]
  },
  "torch.Tensor.rsqrt": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.rsqrt",
    "min_input_args": 0
  },
  "torch.Tensor.rsqrt_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.rsqrt_",
    "min_input_args": 0
  },
  "torch.Tensor.scatter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.put_along_axis",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "value",
      "*",
      "src",
      "reduce"
    ],
    "kwargs_change": {
      "dim": "axis",
      "index": "indices",
      "value": "values"
    },
    "unsupport_args": [
      "src"
    ]
  },
  "torch.Tensor.scatter_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.put_along_axis_",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "value",
      "*",
      "src",
      "reduce"
    ],
    "kwargs_change": {
      "dim": "axis",
      "index": "indices",
      "value": "values"
    },
    "unsupport_args": [
      "src"
    ]
  },
  "torch.Tensor.scatter_add": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.put_along_axis",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "src"
    ],
    "kwargs_change": {
      "dim": "axis",
      "index": "indices",
      "src": "values"
    },
    "paddle_default_kwargs": {
      "reduce": "'add'"
    }
  },
  "torch.Tensor.scatter_add_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.put_along_axis_",
    "min_input_args": 3,
    "args_list": [
      "dim",
      "index",
      "src"
    ],
    "kwargs_change": {
      "dim": "axis",
      "index": "indices",
      "src": "values"
    },
    "paddle_default_kwargs": {
      "reduce": "'add'"
    }
  },
  "torch.Tensor.scatter_reduce": {},
  "torch.Tensor.scatter_reduce_": {},
  "torch.Tensor.select": {
    "Matcher": "SelectMatcher",
    "min_input_args": 2,
    "args_list": [
      "dim",
      "index"
    ]
  },
  "torch.Tensor.select_scatter": {},
  "torch.Tensor.set_": {},
  "torch.Tensor.sgn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sgn",
    "min_input_args": 0
  },
  "torch.Tensor.sgn_": {},
  "torch.Tensor.share_memory_": {
    "min_input_args": 0
  },
  "torch.Tensor.short": {
    "Matcher": "TensorShortMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "*",
      "memory_format"
    ]
  },
  "torch.Tensor.sigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sigmoid",
    "min_input_args": 0
  },
  "torch.Tensor.sigmoid_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sigmoid_",
    "min_input_args": 0
  },
  "torch.Tensor.sign": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.sign_": {},
  "torch.Tensor.signbit": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.signbit",
    "min_input_args": 1,
    "args_list": []
  },
  "torch.Tensor.sin": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.sin_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sin_",
    "min_input_args": 0
  },
  "torch.Tensor.sinc": {
    "Matcher": "SincMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.sinc_": {},
  "torch.Tensor.sinh": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.sinh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sinh_",
    "min_input_args": 0
  },
  "torch.Tensor.size": {
    "Matcher": "TensorSizeMatcher",
    "paddle_api": "paddle.Tensor.shape",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ]
  },
  "torch.Tensor.slice_scatter": {},
  "torch.Tensor.slogdet": {
    "Matcher": "SLogDetMatcher",
    "paddle_api": "paddle.linalg.slogdet",
    "min_input_args": 0
  },
  "torch.Tensor.smm": {},
  "torch.Tensor.softmax": {
    "Matcher": "TensorSoftmaxMatcher",
    "paddle_api": "paddle.nn.functional.softmax",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.Tensor.sort": {
    "Matcher": "SortMatcher",
    "paddle_api": "paddle.sort",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "descending",
      "*",
      "stable",
      "dim",
      "descending"
    ],
    "kwargs_change": {
      "dim": "axis",
      "stable": ""
    }
  },
  "torch.Tensor.sparse_dim": {},
  "torch.Tensor.sparse_mask": {},
  "torch.Tensor.sparse_resize_": {},
  "torch.Tensor.sparse_resize_and_clear_": {},
  "torch.Tensor.split": {
    "Matcher": "TensorSplitMatcher",
    "paddle_api": "paddle.Tensor.split",
    "min_input_args": 1,
    "args_list": [
      "split_size",
      "dim"
    ]
  },
  "torch.Tensor.sqrt": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.sqrt_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sqrt_",
    "min_input_args": 0
  },
  "torch.Tensor.square": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.square",
    "min_input_args": 0
  },
  "torch.Tensor.square_": {
    "Matcher": "TensorFunc2PaddleFunc",
    "paddle_api": "paddle.square_",
    "min_input_args": 0
  },
  "torch.Tensor.squeeze": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.squeeze",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.squeeze_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.squeeze_",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.sspaddmm": {},
  "torch.Tensor.std": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.std",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.Tensor.stft": {
    "min_input_args": 1
  },
  "torch.Tensor.storage": {
    "min_input_args": 0
  },
  "torch.Tensor.storage_offset": {},
  "torch.Tensor.storage_type": {
    "min_input_args": 0
  },
  "torch.Tensor.stride": {},
  "torch.Tensor.subtract": {
    "Matcher": "TensorSubtractMatcher",
    "paddle_api": "paddle.Tensor.subtract",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "alpha"
    ]
  },
  "torch.Tensor.subtract_": {
    "Matcher": "Num2TensorBinaryWithAlphaMatcher",
    "paddle_api": "paddle.Tensor.subtract_",
    "min_input_args": 1,
    "args_list": [
      "other",
      "*",
      "alpha"
    ]
  },
  "torch.Tensor.sum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.sum",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "keepdim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.Tensor.sum_to_size": {},
  "torch.Tensor.svd": {
    "Matcher": "SvdMatcher",
    "paddle_api": "paddle.linalg.svd",
    "min_input_args": 0,
    "args_list": [
      "some",
      "compute_uv"
    ],
    "unsupport_args": [
      "compute_uv"
    ]
  },
  "torch.Tensor.swapaxes": {
    "Matcher": "SwapAxesMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 2,
    "args_list": [
      "axis0",
      "axis1"
    ]
  },
  "torch.Tensor.swapdims": {
    "Matcher": "SwapAxesMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 2,
    "args_list": [
      "dim0",
      "dim1"
    ]
  },
  "torch.Tensor.symeig": {
    "Matcher": "SymeigMatcher",
    "paddle_api": "paddle.linalg.eigh",
    "min_input_args": 0,
    "args_list": [
      "eigenvectors",
      "upper"
    ]
  },
  "torch.Tensor.t": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.t",
    "min_input_args": 0
  },
  "torch.Tensor.t_": {},
  "torch.Tensor.take": {
    "Matcher": "TensorTakeMatcher",
    "paddle_api": "paddle.Tensor.take",
    "min_input_args": 1,
    "args_list": [
      "index"
    ]
  },
  "torch.Tensor.take_along_dim": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.take_along_axis",
    "min_input_args": 2,
    "args_list": [
      "indices",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.tan": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.tan",
    "min_input_args": 0
  },
  "torch.Tensor.tan_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.tan_",
    "min_input_args": 0
  },
  "torch.Tensor.tanh": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.tanh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.tanh_",
    "min_input_args": 0
  },
  "torch.Tensor.tensor_split": {},
  "torch.Tensor.tile": {
    "Matcher": "TensorTileMatcher",
    "paddle_api": "paddle.Tensor.tile",
    "min_input_args": 1,
    "args_list": [
      "*dims"
    ]
  },
  "torch.Tensor.to": {
    "Matcher": "TensorToMatcher",
    "paddle_api": "paddle.Tensor.to",
    "min_input_args": 1,
    "args_list": [
      "other",
      "device",
      "dtype",
      "non_blocking",
      "copy",
      "memory_format"
    ]
  },
  "torch.Tensor.to_dense": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.to_dense",
    "min_input_args": 0
  },
  "torch.Tensor.to_mkldnn": {},
  "torch.Tensor.to_sparse": {
    "Matcher": "GenericMatcher",
    "min_input_args": 1,
    "paddle_api": "paddle.Tensor.to_sparse_coo",
    "args_list": [
      "sparse_dim"
    ]
  },
  "torch.Tensor.tolist": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.topk": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.topk",
    "min_input_args": 1,
    "args_list": [
      "k",
      "dim",
      "largest",
      "sorted"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.trace": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.transpose": {
    "Matcher": "TensorTransposeMatcher",
    "paddle_api": "paddle.Tensor.transpose",
    "min_input_args": 2,
    "args_list": [
      "dim0",
      "dim1"
    ]
  },
  "torch.Tensor.transpose_": {},
  "torch.Tensor.triangular_solve": {
    "Matcher": "TensorTriangularSolveMatcher",
    "paddle_api": "paddle.linalg.triangular_solve",
    "min_input_args": 1,
    "args_list": [
      "A",
      "upper",
      "transpose",
      "unitriangular"
    ]
  },
  "torch.Tensor.tril": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.tril",
    "min_input_args": 0,
    "args_list": [
      "diagonal"
    ]
  },
  "torch.Tensor.tril_": {
    "Matcher": "GenericMatcher",
    "min_input_args": 0,
    "paddle_api": "paddle.Tensor.tril_",
    "args_list": [
      "diagonal"
    ]
  },
  "torch.Tensor.triu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.triu",
    "min_input_args": 0,
    "args_list": [
      "diagonal"
    ]
  },
  "torch.Tensor.triu_": {
    "Matcher": "GenericMatcher",
    "min_input_args": 0,
    "paddle_api": "paddle.Tensor.triu_",
    "args_list": [
      "diagonal"
    ]
  },
  "torch.Tensor.true_divide": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.divide",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.true_divide_": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.Tensor.divide_",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.trunc": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.trunc_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.trunc_",
    "min_input_args": 0
  },
  "torch.Tensor.type": {
    "Matcher": "TensorTypeMatcher",
    "paddle_api": "paddle.Tensor.astype",
    "min_input_args": 0,
    "args_list": [
      "dtype",
      "non_blocking",
      "dst_type"
    ]
  },
  "torch.Tensor.type_as": {
    "Matcher": "TensorTypeAsMatcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.unbind": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unbind",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.unflatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unflatten",
    "min_input_args": 2,
    "args_list": [
      "dim",
      "sizes"
    ],
    "kwargs_change": {
      "dim": "axis",
      "sizes": "shape"
    }
  },
  "torch.Tensor.unfold": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unfold",
    "min_input_args": 3,
    "args_list": [
      "dimension",
      "size",
      "step"
    ],
    "kwargs_change": {
      "dimension": "axis"
    }
  },
  "torch.Tensor.uniform_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.uniform_",
    "min_input_args": 0,
    "args_list": [
      "from",
      "to"
    ],
    "kwargs_change": {
      "from": "min",
      "to": "max"
    }
  },
  "torch.Tensor.unique": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unique",
    "min_input_args": 0,
    "args_list": [
      "sorted",
      "return_inverse",
      "return_counts",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    },
    "unsupport_args": [
      "sorted"
    ]
  },
  "torch.Tensor.unique_consecutive": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unique_consecutive",
    "min_input_args": 0,
    "args_list": [
      "return_inverse",
      "return_counts",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.unsqueeze": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unsqueeze",
    "min_input_args": 1,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.unsqueeze_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.unsqueeze_",
    "min_input_args": 1,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.Tensor.values": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.Tensor.var": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.var",
    "args_list": [
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim"
    ],
    "kwargs_change": {
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.Tensor.vdot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.dot",
    "min_input_args": 1,
    "args_list": [
      "other"
    ],
    "kwargs_change": {
      "other": "y"
    }
  },
  "torch.Tensor.view": {
    "Matcher": "TensorViewMatcher",
    "paddle_api": "paddle.Tensor.view",
    "min_input_args": 1,
    "args_list": [
      "*size",
      "dtype"
    ]
  },
  "torch.Tensor.view_as": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.view_as",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.vsplit": {},
  "torch.Tensor.where": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.where",
    "min_input_args": 2,
    "args_list": [
      "condition",
      "y"
    ]
  },
  "torch.Tensor.xlogy": {
    "Matcher": "XLogYMatcher",
    "min_input_args": 1,
    "args_list": [
      "other"
    ]
  },
  "torch.Tensor.xlogy_": {},
  "torch.Tensor.zero_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.Tensor.zero_",
    "min_input_args": 0
  },
  "torch.abs": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.abs",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.abs_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.abs_",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.adaptive_max_pool1d": {},
  "torch.add": {
    "Matcher": "Num2TensorBinaryWithAlphaMatcher",
    "paddle_api": "paddle.add",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "alpha",
      "out"
    ]
  },
  "torch.addbmm": {
    "Matcher": "AddBmmMatcher",
    "min_input_args": 3,
    "args_list": [
      "input",
      "batch1",
      "batch2",
      "*",
      "beta",
      "alpha",
      "out"
    ]
  },
  "torch.addcdiv": {
    "Matcher": "AddCDivMatcher",
    "min_input_args": 3,
    "args_list": [
      "input",
      "tensor1",
      "tensor2",
      "*",
      "value",
      "out"
    ]
  },
  "torch.addcmul": {
    "Matcher": "AddCMulMatcher",
    "min_input_args": 3,
    "args_list": [
      "input",
      "tensor1",
      "tensor2",
      "*",
      "value",
      "out"
    ]
  },
  "torch.addmm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.addmm",
    "min_input_args": 3,
    "args_list": [
      "input",
      "mat1",
      "mat2",
      "*",
      "beta",
      "alpha",
      "out"
    ],
    "kwargs_change": {
      "mat1": "x",
      "mat2": "y"
    }
  },
  "torch.addmv": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.mm",
    "min_input_args": 3,
    "args_list": [
      "input",
      "mat",
      "vec",
      "*",
      "beta",
      "alpha",
      "out"
    ]
  },
  "torch.addr": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.outer",
    "min_input_args": 3,
    "args_list": [
      "input",
      "vec1",
      "vec2",
      "*",
      "beta",
      "alpha",
      "out"
    ]
  },
  "torch.adjoint": {
    "Matcher": "AdjointMatcher",
    "min_input_args": 1,
    "args_list": [
      "input"
    ]
  },
  "torch.all": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.all",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.allclose": {
    "Matcher": "AllcloseMatcher",
    "paddle_api": "paddle.allclose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.alpha_dropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.alpha_dropout",
    "min_input_args": 3,
    "args_list": [
      "input",
      "p",
      "train"
    ],
    "kwargs_change": {
      "input": "x",
      "train": "training"
    }
  },
  "torch.amax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amax",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.amin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amin",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.aminmax": {
    "Matcher": "AMinMaxMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dim",
      "keepdim",
      "out"
    ]
  },
  "torch.angle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.angle",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.any": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.any",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.arange": {
    "Matcher": "ArangeMatcher",
    "paddle_api": "paddle.arange",
    "min_input_args": 1,
    "args_list": [
      "start",
      "end",
      "step",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.arccos": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.acos",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.arccosh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.acosh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.arcsin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.asin",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.arcsinh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.asinh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.arctan": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.atan",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.arctan2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.atan2",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.arctanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.atanh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.argmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.argmax",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.argmin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.argmin",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.argsort": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.argsort",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "descending",
      "stable"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "unsupport_args": [
      "stable"
    ]
  },
  "torch.argwhere": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nonzero",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.as_strided": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.as_strided",
    "min_input_args": 3,
    "args_list": [
      "input",
      "size",
      "stride",
      "storage_offset"
    ],
    "kwargs_change": {
      "input": "x",
      "size": "shape",
      "storage_offset": "offset"
    }
  },
  "torch.as_tensor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "data",
      "*",
      "dtype",
      "device"
    ],
    "kwargs_change": {
      "dtype": "dtype",
      "device": "place"
    }
  },
  "torch.asarray": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "obj",
      "*",
      "dtype",
      "device",
      "copy",
      "requires_grad"
    ],
    "kwargs_change": {
      "obj": "data",
      "dtype": "dtype",
      "device": "place",
      "copy": ""
    }
  },
  "torch.atleast_1d": {
    "Matcher": "AtleastMatcher",
    "paddle_api": "paddle.atleast_1d",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.atleast_2d": {
    "Matcher": "AtleastMatcher",
    "paddle_api": "paddle.atleast_2d",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.atleast_3d": {
    "Matcher": "AtleastMatcher",
    "paddle_api": "paddle.atleast_3d",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.autocast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amp.auto_cast",
    "min_input_args": 1,
    "args_list": [
      "device_type",
      "dtype",
      "enabled",
      "cache_enabled"
    ],
    "kwargs_change": {
      "device_type": "",
      "dtype": "dtype",
      "enabled": "enable",
      "cache_enabled": ""
    }
  },
  "torch.autograd.Function": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.autograd.PyLayer",
    "abstract": true,
    "min_input_args": 0
  },
  "torch.autograd.Function.backward": {
    "abstract": true,
    "min_input_args": 1
  },
  "torch.autograd.Function.forward": {
    "abstract": true,
    "min_input_args": 1
  },
  "torch.autograd.backward": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.autograd.backward",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "grad_tensors",
      "retain_graph",
      "create_graph",
      "grad_variables",
      "inputs"
    ],
    "unsupport_args": [
      "create_graph",
      "grad_variables",
      "inputs"
    ]
  },
  "torch.autograd.enable_grad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.enable_grad",
    "min_input_args": 0
  },
  "torch.autograd.function.FunctionCtx": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.autograd.PyLayerContext",
    "min_input_args": 0
  },
  "torch.autograd.function.FunctionCtx.mark_dirty": {
    "min_input_args": 0
  },
  "torch.autograd.function.FunctionCtx.mark_non_differentiable": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "*args"
    ]
  },
  "torch.autograd.function.FunctionCtx.mark_shared_storage": {
    "min_input_args": 0
  },
  "torch.autograd.function.FunctionCtx.save_for_backward": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.autograd.function.FunctionCtx.save_for_forward": {
    "min_input_args": 0
  },
  "torch.autograd.function.FunctionCtx.set_materialize_grads": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "value"
    ]
  },
  "torch.autograd.functional.hessian": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.incubate.autograd.Hessian",
    "min_input_args": 2,
    "args_list": [
      "func",
      "inputs",
      "create_graph",
      "strict",
      "vectorize",
      "outer_jacobian_strategy"
    ],
    "unsupport_args": [
      "create_graph",
      "strict",
      "vectorize",
      "outer_jacobian_strategy"
    ],
    "kwargs_change": {
      "inputs": "xs"
    },
    "paddle_default_kwargs": {
      "is_batched": "False"
    }
  },
  "torch.autograd.functional.jacobian": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.incubate.autograd.Jacobian",
    "min_input_args": 2,
    "args_list": [
      "func",
      "inputs",
      "create_graph",
      "strict",
      "vectorize",
      "strategy"
    ],
    "unsupport_args": [
      "create_graph",
      "strict",
      "vectorize",
      "strategy"
    ],
    "kwargs_change": {
      "inputs": "xs"
    },
    "paddle_default_kwargs": {
      "is_batched": "False"
    }
  },
  "torch.autograd.functional.jvp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.incubate.autograd.jvp",
    "min_input_args": 2,
    "args_list": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "unsupport_args": [
      "create_graph",
      "strict"
    ],
    "kwargs_change": {
      "inputs": "xs"
    }
  },
  "torch.autograd.functional.vjp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.incubate.autograd.vjp",
    "min_input_args": 2,
    "args_list": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "unsupport_args": [
      "create_graph",
      "strict"
    ],
    "kwargs_change": {
      "inputs": "xs"
    }
  },
  "torch.autograd.grad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.grad",
    "min_input_args": 2,
    "args_list": [
      "outputs",
      "inputs",
      "grad_outputs",
      "retain_graph",
      "create_graph",
      "only_inputs",
      "allow_unused",
      "is_grads_batched"
    ],
    "kwargs_change": {
      "is_grads_batched": ""
    },
    "unsupport_args": [
      "only_inputs"
    ]
  },
  "torch.autograd.graph.saved_tensors_hooks": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.autograd.saved_tensors_hooks",
    "min_input_args": 2,
    "args_list": [
      "pack_hook",
      "unpack_hook"
    ]
  },
  "torch.autograd.profiler.profile": {
    "min_input_args": 0
  },
  "torch.autograd.profiler.profile.config": {
    "min_input_args": 0
  },
  "torch.autograd.profiler.profile.export_chrome_trace": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.profiler.export_chrome_tracing",
    "min_input_args": 1,
    "args_list": [
      "path"
    ],
    "kwargs_change": {
      "path": "dir_name"
    }
  },
  "torch.autograd.profiler.profile.export_stacks": {
    "min_input_args": 1
  },
  "torch.autograd.profiler.profile.key_averages": {
    "min_input_args": 0
  },
  "torch.autograd.profiler.profile.table": {
    "min_input_args": 0
  },
  "torch.autograd.profiler.profile.total_average": {
    "min_input_args": 0
  },
  "torch.autograd.set_grad_enabled": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_grad_enabled",
    "min_input_args": 1,
    "args_list": [
      "mode"
    ]
  },
  "torch.backends.cuda.is_built": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.is_compiled_with_cuda",
    "min_input_args": 0
  },
  "torch.backends.cudnn.is_available": {
    "Matcher": "CudnnIsAvailableMatcher",
    "min_input_args": 0
  },
  "torch.backends.cudnn.version": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.get_cudnn_version",
    "min_input_args": 0
  },
  "torch.baddbmm": {
    "Matcher": "AddMRMatcher",
    "paddle_api": "paddle.bmm",
    "min_input_args": 3,
    "args_list": [
      "input",
      "batch1",
      "batch2",
      "*",
      "beta",
      "alpha",
      "out"
    ]
  },
  "torch.batch_norm": {},
  "torch.bernoulli": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bernoulli",
    "args_list": [
      "input",
      "p",
      "*",
      "generator",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "p"
    ]
  },
  "torch.binary_cross_entropy_with_logits": {},
  "torch.bincount": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bincount",
    "min_input_args": 1,
    "args_list": [
      "input",
      "weights",
      "minlength"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.bitwise_and": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bitwise_and",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.bitwise_not": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bitwise_not",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.bitwise_or": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bitwise_or",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.bitwise_xor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bitwise_xor",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.bmm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bmm",
    "min_input_args": 2,
    "args_list": [
      "input",
      "mat2",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "mat2": "y"
    }
  },
  "torch.broadcast_shapes": {
    "Matcher": "BroadcastShapesMatcher",
    "paddle_api": "paddle.broadcast_shape",
    "min_input_args": 1,
    "args_list": [
      "*shapes"
    ]
  },
  "torch.broadcast_tensors": {
    "Matcher": "BroadcastTensorsMatcher",
    "paddle_api": "paddle.broadcast_tensors",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.broadcast_to": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.broadcast_to",
    "min_input_args": 2,
    "args_list": [
      "input",
      "size"
    ],
    "kwargs_change": {
      "input": "x",
      "size": "shape"
    }
  },
  "torch.bucketize": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.bucketize",
    "min_input_args": 2,
    "args_list": [
      "input",
      "boundaries",
      "*",
      "out_int32",
      "right",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "boundaries": "sorted_sequence"
    }
  },
  "torch.cat": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.concat",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x",
      "dim": "axis"
    }
  },
  "torch.cdist": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cdist",
    "min_input_args": 2,
    "args_list": [
      "x1",
      "x2",
      "p",
      "compute_mode"
    ],
    "kwargs_change": {
      "x1": "x",
      "x2": "y"
    }
  },
  "torch.ceil": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.ceil",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.celu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.celu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "alpha"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.chain_matmul": {
    "Matcher": "Chain_MatmulMatcher",
    "min_input_args": 1,
    "args_list": [
      "*matrices",
      "out"
    ]
  },
  "torch.cholesky": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.cholesky",
    "min_input_args": 1,
    "args_list": [
      "input",
      "upper",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.cholesky_inverse": {
    "Matcher": "CholeskyInverseMatcher",
    "paddle_api": "paddle.linalg.inv",
    "min_input_args": 1,
    "args_list": [
      "input",
      "upper",
      "*",
      "out"
    ]
  },
  "torch.cholesky_solve": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.cholesky_solve",
    "min_input_args": 2,
    "args_list": [
      "input",
      "input2",
      "upper",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "input2": "y"
    }
  },
  "torch.chunk": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.chunk",
    "min_input_args": 2,
    "args_list": [
      "input",
      "chunks",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.clamp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.clip",
    "min_input_args": 1,
    "args_list": [
      "input",
      "min",
      "max",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.clamp_max": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.clip",
    "min_input_args": 2,
    "args_list": [
      "input",
      "max",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.clamp_min": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.clip",
    "min_input_args": 2,
    "args_list": [
      "input",
      "min",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.clone": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.clone",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.column_stack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.column_stack",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x"
    }
  },
  "torch.combinations": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.combinations",
    "min_input_args": 1,
    "args_list": [
      "input",
      "r",
      "with_replacement"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.complex": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.complex",
    "min_input_args": 2,
    "args_list": [
      "real",
      "imag",
      "*",
      "out"
    ]
  },
  "torch.concat": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.concat",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x",
      "dim": "axis"
    }
  },
  "torch.conj": {
    "Matcher": "GenericMatcher",
    "min_input_args": 1,
    "paddle_api": "paddle.conj",
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.conj_physical": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.conj",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.corrcoef": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.corrcoef",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "paddle_default_kwargs": {
      "rowvar": "True"
    }
  },
  "torch.cos": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cos",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.cosh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cosh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.cosine_embedding_loss": {},
  "torch.count_nonzero": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.count_nonzero",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.cov": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.cov",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "correction",
      "fweights",
      "aweights"
    ],
    "kwargs_change": {
      "input": "x",
      "correction": "ddof"
    }
  },
  "torch.cpu.amp.autocast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amp.auto_cast",
    "min_input_args": 0,
    "args_list": [
      "enabled",
      "dtype",
      "cache_enabled"
    ],
    "kwargs_change": {
      "enabled": "enable",
      "dtype": "dtype",
      "cache_enabled": ""
    }
  },
  "torch.cross": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cross",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y",
      "dim": "axis"
    }
  },
  "torch.ctc_loss": {},
  "torch.cuda.BoolTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.bool"
  },
  "torch.cuda.ByteTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.uint8"
  },
  "torch.cuda.DoubleTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float64"
  },
  "torch.cuda.Event": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.Event",
    "min_input_args": 0,
    "args_list": [
      "enable_timing",
      "blocking",
      "interprocess"
    ]
  },
  "torch.cuda.FloatTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float32"
  },
  "torch.cuda.HalfTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.float16"
  },
  "torch.cuda.IntTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int32"
  },
  "torch.cuda.LongTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int64"
  },
  "torch.cuda.ShortTensor": {
    "Matcher": "TensorMatcher",
    "paddle_api": "paddle.int16"
  },
  "torch.cuda.Stream": {
    "Matcher": "CudaStreamMatcher",
    "paddle_api": "paddle.device.cuda.Stream",
    "args_list": [
      "device",
      "priority"
    ],
    "kwargs_change": {
      "device": "device"
    },
    "min_input_args": 0
  },
  "torch.cuda.amp.GradScaler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amp.GradScaler",
    "args_list": [
      "init_scale",
      "growth_factor",
      "backoff_factor",
      "growth_interval",
      "enabled"
    ],
    "kwargs_change": {
      "init_scale": "init_loss_scaling",
      "growth_factor": "incr_ratio",
      "backoff_factor": "decr_ratio",
      "growth_interval": "incr_every_n_steps",
      "enabled": "enable"
    },
    "paddle_default_kwargs": {
      "incr_every_n_steps": 2000,
      "init_loss_scaling": 65536.0
    },
    "min_input_args": 0
  },
  "torch.cuda.amp.autocast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.amp.auto_cast",
    "min_input_args": 0,
    "args_list": [
      "enabled",
      "dtype",
      "cache_enabled"
    ],
    "kwargs_change": {
      "enabled": "enable",
      "dtype": "dtype",
      "cache_enabled": ""
    }
  },
  "torch.cuda.current_device": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.framework._current_expected_place",
    "min_input_args": 0
  },
  "torch.cuda.current_stream": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.current_stream",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.device_count": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.device_count",
    "min_input_args": 0
  },
  "torch.cuda.empty_cache": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.empty_cache",
    "min_input_args": 0
  },
  "torch.cuda.get_device_capability": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.get_device_capability",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.get_device_name": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.get_device_name",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.get_device_properties": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.get_device_properties",
    "min_input_args": 1,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.get_rng_state_all": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.get_rng_state",
    "min_input_args": 0
  },
  "torch.cuda.initial_seed": {
    "Matcher": "CudaSeedMatcher",
    "min_input_args": 0
  },
  "torch.cuda.is_available": {
    "Matcher": "CudaIsAvailableMatcher",
    "paddle_api": "paddle.device.cuda.device_count",
    "min_input_args": 0
  },
  "torch.cuda.manual_seed": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.seed",
    "min_input_args": 1,
    "args_list": [
      "seed"
    ]
  },
  "torch.cuda.manual_seed_all": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.seed",
    "min_input_args": 1,
    "args_list": [
      "seed"
    ]
  },
  "torch.cuda.max_memory_allocated": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.max_memory_allocated",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.max_memory_reserved": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.max_memory_reserved",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.memory_allocated": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.memory_allocated",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.memory_reserved": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.memory_reserved",
    "min_input_args": 0,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.nvtx.range_pop": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.framework.core.nvprof_nvtx_pop",
    "min_input_args": 0
  },
  "torch.cuda.nvtx.range_push": {
    "Matcher": "CudaNvtxRangePushMatcher",
    "paddle_api": "paddle.framework.core.nvprof_nvtx_push",
    "min_input_args": 1,
    "args_list": [
      "msg"
    ]
  },
  "torch.cuda.set_device": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.set_device",
    "min_input_args": 1,
    "args_list": [
      "device"
    ],
    "kwargs_change": {
      "device": "device"
    }
  },
  "torch.cuda.set_rng_state_all": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_rng_state",
    "min_input_args": 1,
    "args_list": [
      "new_states"
    ],
    "kwargs_change": {
      "new_states": "state_list"
    }
  },
  "torch.cuda.set_stream": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.set_stream",
    "min_input_args": 0,
    "args_list": [
      "stream"
    ]
  },
  "torch.cuda.stream": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.stream_guard",
    "min_input_args": 1,
    "args_list": [
      "stream"
    ]
  },
  "torch.cuda.synchronize": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.device.cuda.synchronize",
    "min_input_args": 0,
    "args_list": [
      "device"
    ]
  },
  "torch.cummax": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.cummax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.cummin": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.cummin",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.cumprod": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cumprod",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "torch.cumsum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cumsum",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.cumulative_trapezoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cumulative_trapezoid",
    "min_input_args": 1,
    "args_list": [
      "y",
      "x",
      "*",
      "dx",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.deg2rad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.deg2rad",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.det": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.det",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.device": {
    "Matcher": "DeviceMatcher",
    "paddle_api": "str",
    "min_input_args": 1,
    "args_list": [
      "type",
      "index"
    ]
  },
  "torch.diag": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diag",
    "min_input_args": 1,
    "args_list": [
      "input",
      "diagonal",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "diagonal": "offset"
    }
  },
  "torch.diag_embed": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diag_embed",
    "min_input_args": 1,
    "args_list": [
      "input",
      "offset",
      "dim1",
      "dim2"
    ]
  },
  "torch.diagflat": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diagflat",
    "min_input_args": 1,
    "args_list": [
      "input",
      "offset"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.diagonal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diagonal",
    "min_input_args": 1,
    "args_list": [
      "input",
      "offset",
      "dim1",
      "dim2"
    ],
    "kwargs_change": {
      "input": "x",
      "dim1": "axis1",
      "dim2": "axis2"
    }
  },
  "torch.diagonal_scatter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diagonal_scatter",
    "min_input_args": 2,
    "args_list": [
      "input",
      "src",
      "offset",
      "dim1",
      "dim2"
    ],
    "kwargs_change": {
      "input": "x",
      "src": "y",
      "dim1": "axis1",
      "dim2": "axis2"
    }
  },
  "torch.diff": {
    "Matcher": "DiffMatcher",
    "paddle_api": "paddle.diff",
    "args_list": [
      "input",
      "n",
      "dim",
      "prepend",
      "append",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.dist": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.dist",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "p"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.distributed.ReduceOp": {
    "Matcher": "Func2Attribute",
    "paddle_api": "paddle.distributed.ReduceOp"
  },
  "torch.distributed.all_gather": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.all_gather",
    "args_list": [
      "tensor_list",
      "tensor",
      "group",
      "async_op"
    ],
    "min_input_args": 2
  },
  "torch.distributed.all_gather_object": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.all_gather_object",
    "args_list": [
      "object_list",
      "obj",
      "group"
    ],
    "min_input_args": 2
  },
  "torch.distributed.all_reduce": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.all_reduce",
    "args_list": [
      "tensor",
      "op",
      "group",
      "async_op"
    ],
    "min_input_args": 1
  },
  "torch.distributed.all_to_all": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.alltoall",
    "args_list": [
      "output_tensor_list",
      "input_tensor_list",
      "group",
      "async_op"
    ],
    "kwargs_change": {
      "output_tensor_list": "out_tensor_list",
      "input_tensor_list": "in_tensor_list",
      "async_op": ""
    },
    "min_input_args": 2
  },
  "torch.distributed.barrier": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.barrier",
    "args_list": [
      "group"
    ],
    "min_input_args": 0
  },
  "torch.distributed.broadcast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.broadcast",
    "args_list": [
      "tensor",
      "src",
      "group",
      "async_op"
    ],
    "unsupport_args": [
      "async_op"
    ],
    "min_input_args": 2
  },
  "torch.distributed.broadcast_object_list": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.broadcast_object_list",
    "args_list": [
      "object_list",
      "src",
      "group",
      "device"
    ],
    "kwargs_change": {
      "device": ""
    },
    "min_input_args": 1
  },
  "torch.distributed.gather": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.gather",
    "args_list": [
      "tensor",
      "gather_list",
      "dst",
      "group",
      "async_op"
    ],
    "min_input_args": 1
  },
  "torch.distributed.get_backend": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.get_backend",
    "args_list": [
      "group"
    ],
    "min_input_args": 0
  },
  "torch.distributed.get_rank": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.get_rank",
    "min_input_args": 0
  },
  "torch.distributed.init_process_group": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.init_parallel_env",
    "args_list": [
      "backend",
      "init_method",
      "timeout",
      "world_size",
      "rank",
      "store",
      "group_name",
      "pg_options"
    ],
    "kwargs_change": {
      "backend": "",
      "init_method": "",
      "timeout": "",
      "world_size": "",
      "rank": "",
      "store": "",
      "group_name": "",
      "pg_options": ""
    },
    "min_input_args": 0
  },
  "torch.distributed.irecv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.irecv",
    "args_list": [
      "tensor",
      "src",
      "group",
      "tag"
    ],
    "unsupport_args": [
      "tag"
    ],
    "min_input_args": 1
  },
  "torch.distributed.isend": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.isend",
    "args_list": [
      "tensor",
      "dst",
      "group",
      "tag"
    ],
    "unsupport_args": [
      "tag"
    ],
    "min_input_args": 2
  },
  "torch.distributed.new_group": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.new_group",
    "args_list": [
      "ranks",
      "timeout",
      "backend",
      "pg_options"
    ],
    "unsupport_args": [
      "timeout",
      "pg_options"
    ],
    "min_input_args": 0
  },
  "torch.distributed.recv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.recv",
    "args_list": [
      "tensor",
      "src",
      "group",
      "tag"
    ],
    "unsupport_args": [
      "tag"
    ],
    "min_input_args": 1
  },
  "torch.distributed.reduce": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.reduce",
    "args_list": [
      "tensor",
      "dst",
      "op",
      "group",
      "async_op"
    ],
    "min_input_args": 2
  },
  "torch.distributed.reduce_scatter": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.reduce_scatter",
    "args_list": [
      "output",
      "input_list",
      "op",
      "group",
      "async_op"
    ],
    "kwargs_change": {
      "output": "tensor",
      "input_list": "tensor_list"
    },
    "min_input_args": 2
  },
  "torch.distributed.rpc.get_worker_info": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.rpc.get_worker_info",
    "args_list": [
      "worker_name"
    ],
    "kwargs_change": {
      "worker_name": "name"
    },
    "min_input_args": 0
  },
  "torch.distributed.rpc.init_rpc": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.rpc.init_rpc",
    "args_list": [
      "name",
      "backend",
      "rank",
      "world_size",
      "rpc_backend_options"
    ],
    "unsupport_args": [
      "rpc_backend_options"
    ],
    "min_input_args": 1
  },
  "torch.distributed.rpc.shutdown": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.rpc.shutdown",
    "min_input_args": 0
  },
  "torch.distributed.scatter": {
    "Matcher": "ScatterMatcher",
    "paddle_api": "paddle.distributed.scatter",
    "args_list": [
      "tensor",
      "scatter_list",
      "src",
      "group",
      "async_op"
    ],
    "kwargs_change": {
      "scatter_list": "tensor_list"
    },
    "min_input_args": 1
  },
  "torch.distributed.scatter_object_list": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.scatter_object_list",
    "args_list": [
      "scatter_object_output_list",
      "scatter_object_input_list",
      "src",
      "group"
    ],
    "kwargs_change": {
      "scatter_object_output_list": "out_object_list",
      "scatter_object_input_list": "in_object_list"
    },
    "min_input_args": 2
  },
  "torch.distributed.send": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.send",
    "args_list": [
      "tensor",
      "dst",
      "group",
      "tag"
    ],
    "unsupport_args": [
      "tag"
    ],
    "min_input_args": 2
  },
  "torch.distributions.AbsTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.AbsTransform",
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    },
    "min_input_args": 0
  },
  "torch.distributions.AffineTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.AffineTransform",
    "args_list": [
      "loc",
      "scale",
      "event_dim",
      "cache_size"
    ],
    "kwargs_change": {
      "event_dim": "",
      "cache_size": ""
    },
    "min_input_args": 2
  },
  "torch.distributions.Bernoulli": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Bernoulli",
    "min_input_args": 1,
    "args_list": [
      "probs",
      "logits",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    },
    "unsupport_args": [
      "logits"
    ]
  },
  "torch.distributions.Beta": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Beta",
    "min_input_args": 2,
    "args_list": [
      "concentration1",
      "concentration0",
      "validate_args"
    ],
    "kwargs_change": {
      "concentration1": "alpha",
      "concentration0": "beta",
      "validate_args": ""
    }
  },
  "torch.distributions.Categorical": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Categorical",
    "min_input_args": 1,
    "args_list": [
      "probs",
      "logits",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    },
    "unsupport_args": [
      "probs"
    ]
  },
  "torch.distributions.Cauchy": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Cauchy",
    "min_input_args": 2,
    "args_list": [
      "loc",
      "scale",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.ComposeTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.ChainTransform",
    "min_input_args": 1,
    "args_list": [
      "parts",
      "cache_size"
    ],
    "kwargs_change": {
      "parts": "transforms",
      "cache_size": ""
    }
  },
  "torch.distributions.Dirichlet": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Dirichlet",
    "min_input_args": 1,
    "args_list": [
      "concentration",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.Distribution": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Distribution",
    "min_input_args": 0,
    "args_list": [
      "batch_shape",
      "event_shape",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.Distribution.cdf": {
    "min_input_args": 1
  },
  "torch.distributions.Distribution.concentration0": {},
  "torch.distributions.Distribution.concentration1": {},
  "torch.distributions.Distribution.entropy": {
    "min_input_args": 0
  },
  "torch.distributions.Distribution.enumerate_support": {
    "min_input_args": 0
  },
  "torch.distributions.Distribution.expand": {
    "min_input_args": 1
  },
  "torch.distributions.Distribution.icdf": {
    "min_input_args": 1
  },
  "torch.distributions.Distribution.log_prob": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1
  },
  "torch.distributions.Distribution.logits": {},
  "torch.distributions.Distribution.param_shape": {},
  "torch.distributions.Distribution.perplexity": {
    "min_input_args": 0
  },
  "torch.distributions.Distribution.probs": {},
  "torch.distributions.Distribution.rsample": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Distribution.rsample",
    "args_list": [
      "sample_shape"
    ],
    "kwargs_change": {
      "sample_shape": "shape"
    },
    "min_input_args": 0
  },
  "torch.distributions.Distribution.sample": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Distribution.sample",
    "args_list": [
      "sample_shape"
    ],
    "kwargs_change": {
      "sample_shape": "shape"
    },
    "min_input_args": 0
  },
  "torch.distributions.Distribution.sample_n": {
    "min_input_args": 1
  },
  "torch.distributions.Distribution.set_default_validate_args": {
    "min_input_args": 1
  },
  "torch.distributions.ExpTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.ExpTransform",
    "args_list": [],
    "min_input_args": 0
  },
  "torch.distributions.ExponentialFamily": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.ExponentialFamily",
    "min_input_args": 0,
    "args_list": [
      "batch_shape",
      "event_shape",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.Geometric": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Geometric",
    "min_input_args": 1,
    "args_list": [
      "probs",
      "logits",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    },
    "unsupport_args": [
      "logits"
    ]
  },
  "torch.distributions.Gumbel": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Gumbel",
    "min_input_args": 2,
    "args_list": [
      "loc",
      "scale",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.Independent": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Independent",
    "min_input_args": 2,
    "args_list": [
      "base_distribution",
      "reinterpreted_batch_ndims",
      "validate_args"
    ],
    "kwargs_change": {
      "base_distribution": "base",
      "reinterpreted_batch_ndims": "reinterpreted_batch_rank",
      "validate_args": ""
    }
  },
  "torch.distributions.IndependentTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.IndependentTransform",
    "args_list": [
      "base_transform",
      "reinterpreted_batch_ndims"
    ],
    "kwargs_change": {
      "base_transform": "base",
      "reinterpreted_batch_ndims": "reinterpreted_batch_rank"
    },
    "min_input_args": 2
  },
  "torch.distributions.Laplace": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Laplace",
    "min_input_args": 2,
    "args_list": [
      "loc",
      "scale",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.LogNormal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.LogNormal",
    "min_input_args": 2,
    "args_list": [
      "loc",
      "scale",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.Multinomial": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Multinomial",
    "min_input_args": 2,
    "args_list": [
      "total_count",
      "probs",
      "logits",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    },
    "unsupport_args": [
      "logits"
    ]
  },
  "torch.distributions.Normal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Normal",
    "min_input_args": 2,
    "args_list": [
      "loc",
      "scale",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.PowerTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.PowerTransform",
    "args_list": [
      "exponent",
      "cache_size"
    ],
    "kwargs_change": {
      "exponent": "power",
      "cache_size": ""
    },
    "min_input_args": 1
  },
  "torch.distributions.ReshapeTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.ReshapeTransform",
    "args_list": [
      "in_shape",
      "out_shape"
    ],
    "kwargs_change": {
      "in_shape": "in_event_shape",
      "out_shape": "out_event_shape"
    },
    "min_input_args": 2
  },
  "torch.distributions.SigmoidTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.SigmoidTransform",
    "min_input_args": 0,
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    }
  },
  "torch.distributions.SoftmaxTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.SoftmaxTransform",
    "min_input_args": 0,
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    }
  },
  "torch.distributions.StackTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.StackTransform",
    "min_input_args": 1,
    "args_list": [
      "tseq",
      "dim",
      "cache_size"
    ],
    "kwargs_change": {
      "tseq": "transforms",
      "dim": "axis",
      "cache_size": ""
    }
  },
  "torch.distributions.StickBreakingTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.StickBreakingTransform",
    "min_input_args": 0,
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    }
  },
  "torch.distributions.TanhTransform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.TanhTransform",
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    },
    "min_input_args": 0
  },
  "torch.distributions.Transform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Transform",
    "min_input_args": 0,
    "args_list": [
      "cache_size"
    ],
    "kwargs_change": {
      "cache_size": ""
    }
  },
  "torch.distributions.TransformedDistribution": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.TransformedDistribution",
    "min_input_args": 2,
    "args_list": [
      "base_distribution",
      "transforms",
      "validate_args"
    ],
    "kwargs_change": {
      "base_distribution": "base",
      "validate_args": ""
    }
  },
  "torch.distributions.Uniform": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.Uniform",
    "min_input_args": 2,
    "args_list": [
      "low",
      "high",
      "validate_args"
    ],
    "kwargs_change": {
      "validate_args": ""
    }
  },
  "torch.distributions.kl.kl_divergence": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.kl_divergence",
    "min_input_args": 2,
    "args_list": [
      "p",
      "q"
    ]
  },
  "torch.distributions.kl.register_kl": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distribution.register_kl",
    "min_input_args": 2,
    "args_list": [
      "type_p",
      "type_q"
    ],
    "kwargs_change": {
      "type_p": "cls_p",
      "type_q": "cls_q"
    }
  },
  "torch.divide": {
    "Matcher": "DivideMatcher",
    "paddle_api": "paddle.divide",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "rounding_mode",
      "out"
    ]
  },
  "torch.dot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.dot",
    "min_input_args": 2,
    "args_list": [
      "input",
      "tensor",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "tensor": "y"
    }
  },
  "torch.dropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.dropout",
    "min_input_args": 3,
    "args_list": [
      "input",
      "p",
      "train"
    ],
    "kwargs_change": {
      "input": "x",
      "train": "training"
    }
  },
  "torch.eig": {
    "min_input_args": 0
  },
  "torch.einsum": {
    "Matcher": "UnchangeMatcher",
    "paddle_api": "paddle.einsum",
    "min_input_args": 0
  },
  "torch.embedding": {},
  "torch.embedding_bag": {},
  "torch.empty": {
    "Matcher": "CreateMatcher",
    "paddle_api": "paddle.empty",
    "kwargs_change": {
      "dtype": "dtype"
    },
    "min_input_args": 1,
    "args_list": [
      "*size",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory",
      "memory_format"
    ]
  },
  "torch.empty_like": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.empty_like",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "torch.enable_grad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.enable_grad",
    "min_input_args": 0
  },
  "torch.eq": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.equal": {
    "Matcher": "EqualMatcher",
    "paddle_api": "paddle.equal_all",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.exp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.exp",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.eye": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.eye",
    "min_input_args": 1,
    "args_list": [
      "n",
      "m",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "n": "num_rows",
      "m": "num_columns",
      "dtype": "dtype"
    }
  },
  "torch.feature_alpha_dropout": {},
  "torch.fft.fft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.fft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.fft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.fft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.fftfreq": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.fftfreq",
    "min_input_args": 1,
    "args_list": [
      "n",
      "d",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.fft.fftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.fftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.fftshift": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.fftshift",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.hfft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.hfft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.hfft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.hfft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.hfftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.hfftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.ifft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ifft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.ifft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ifft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.ifftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ifftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.ifftshift": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ifftshift",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.ihfft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ihfft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.ihfft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ihfft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.ihfftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.ihfftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.irfft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.irfft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.irfft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.irfft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.irfftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.irfftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.rfft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.rfft",
    "min_input_args": 1,
    "args_list": [
      "input",
      "n",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.fft.rfft2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.rfft2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.fft.rfftfreq": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.rfftfreq",
    "min_input_args": 1,
    "args_list": [
      "n",
      "d",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.fft.rfftn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fft.rfftn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "s",
      "dim",
      "norm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axes"
    }
  },
  "torch.finfo": {
    "Matcher": "IInfoMatcher",
    "paddle_api": "paddle.finfo",
    "min_input_args": 1,
    "args_list": [
      "type"
    ]
  },
  "torch.fix": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.trunc",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.flatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.flatten",
    "min_input_args": 1,
    "args_list": [
      "input",
      "start_dim",
      "end_dim"
    ],
    "kwargs_change": {
      "input": "x",
      "start_dim": "start_axis",
      "end_dim": "stop_axis"
    }
  },
  "torch.flip": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.flip",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dims"
    ],
    "kwargs_change": {
      "input": "x",
      "dims": "axis"
    }
  },
  "torch.fliplr": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.flip",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "paddle_default_kwargs": {
      "axis": 1
    }
  },
  "torch.flipud": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.flip",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "paddle_default_kwargs": {
      "axis": 0
    }
  },
  "torch.floor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.floor",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.floor_divide": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.floor_divide",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.fmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fmax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.fmin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.fmin",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.fmod": {
    "Matcher": "Num2TensorBinaryConvertTypeMatcher",
    "paddle_api": "paddle.mod",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.frac": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.frac",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.frexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.frexp",
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.from_dlpack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.dlpack.from_dlpack",
    "min_input_args": 1,
    "args_list": [
      "ext_tensor"
    ],
    "kwargs_change": {
      "ext_tensor": "dlpack"
    }
  },
  "torch.from_numpy": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "ndarray"
    ],
    "kwargs_change": {
      "ndarray": "data"
    }
  },
  "torch.full": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.full",
    "min_input_args": 2,
    "args_list": [
      "size",
      "fill_value",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "size": "shape",
      "dtype": "dtype"
    }
  },
  "torch.full_like": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.full_like",
    "min_input_args": 2,
    "args_list": [
      "input",
      "fill_value",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "torch.gather": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.take_along_axis",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim",
      "index",
      "*",
      "sparse_grad",
      "out"
    ],
    "kwargs_change": {
      "input": "arr",
      "dim": "axis",
      "index": "indices",
      "sparse_grad": ""
    }
  },
  "torch.gcd": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.gcd",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.ge": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.greater_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.ger": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.outer",
    "min_input_args": 2,
    "args_list": [
      "input",
      "vec2",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "vec2": "y"
    }
  },
  "torch.get_default_dtype": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.get_default_dtype"
  },
  "torch.get_rng_state": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.get_rng_state",
    "min_input_args": 0
  },
  "torch.greater": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.greater_than",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.greater_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.greater_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.gt": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.greater_than",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.heaviside": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.heaviside",
    "min_input_args": 2,
    "args_list": [
      "input",
      "values",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "values": "y"
    }
  },
  "torch.hinge_embedding_loss": {},
  "torch.histc": {
    "Matcher": "HistcMatcher",
    "paddle_api": "paddle.histogram",
    "min_input_args": 1,
    "args_list": [
      "input",
      "bins",
      "min",
      "max",
      "*",
      "out"
    ]
  },
  "torch.histogramdd": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.histogramdd",
    "min_input_args": 2,
    "args_list": [
      "input",
      "bins",
      "*",
      "range",
      "weight",
      "density"
    ],
    "kwargs_change": {
      "input": "x",
      "range": "ranges",
      "weight": "weights"
    }
  },
  "torch.hstack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.hstack",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x"
    }
  },
  "torch.hub.download_url_to_file": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.download.get_weights_path_from_url",
    "args_list": [
      "url",
      "dst",
      "hash_prefix",
      "progress"
    ],
    "kwargs_change": {
      "dst": "",
      "hash_prefix": "",
      "progress": ""
    },
    "min_input_args": 2
  },
  "torch.hub.help": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.hub.help",
    "min_input_args": 2,
    "args_list": [
      "github",
      "model",
      "force_reload",
      "skip_validation",
      "trust_repo"
    ],
    "kwargs_change": {
      "github": "repo_dir",
      "skip_validation": "",
      "trust_repo": ""
    }
  },
  "torch.hub.list": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.hub.list",
    "min_input_args": 1,
    "args_list": [
      "github",
      "force_reload",
      "skip_validation",
      "trust_repo"
    ],
    "kwargs_change": {
      "github": "repo_dir",
      "skip_validation": "",
      "trust_repo": ""
    }
  },
  "torch.hub.load": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.hub.load",
    "min_input_args": 2,
    "args_list": [
      "repo_or_dir",
      "model",
      "*args",
      "source",
      "trust_repo",
      "force_reload",
      "verbose",
      "skip_validation",
      "**kwargs"
    ],
    "kwargs_change": {
      "repo_or_dir": "repo_dir",
      "trust_repo": "",
      "verbose": "",
      "skip_validation": ""
    }
  },
  "torch.hypot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.hypot",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.iinfo": {
    "Matcher": "IInfoMatcher",
    "paddle_api": "paddle.iinfo",
    "min_input_args": 1,
    "args_list": [
      "type"
    ]
  },
  "torch.imag": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.imag",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.index_add": {
    "Matcher": "IndexAddMatcher",
    "paddle_api": "paddle.index_add",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "index",
      "source",
      "*",
      "alpha",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.index_copy": {
    "Matcher": "IndexCopyMatcher",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "index",
      "source",
      "*",
      "out"
    ]
  },
  "torch.index_fill": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.index_fill",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "index",
      "value"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.index_select": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.index_select",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim",
      "index",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.inference_mode": {
    "Matcher": "InferenceModeMatcher",
    "args_list": [
      "mode"
    ]
  },
  "torch.initial_seed": {
    "Matcher": "SeedMatcher",
    "min_input_args": 0
  },
  "torch.inner": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.inner",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.instance_norm": {},
  "torch.inverse": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.inv",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.is_complex": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.is_complex",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.is_floating_point": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.is_floating_point",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.is_grad_enabled": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.is_grad_enabled",
    "min_input_args": 0
  },
  "torch.is_nonzero": {
    "Matcher": "IsNonzeroMatcher",
    "min_input_args": 1,
    "args_list": [
      "input"
    ]
  },
  "torch.is_tensor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.is_tensor",
    "min_input_args": 1,
    "args_list": [
      "obj"
    ],
    "kwargs_change": {
      "obj": "x"
    }
  },
  "torch.isclose": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.isclose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.isfinite": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.isfinite",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.isinf": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.isinf",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.isnan": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.isnan",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.istft": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.signal.istft",
    "min_input_args": 2,
    "args_list": [
      "input",
      "n_fft",
      "hop_length",
      "win_length",
      "window",
      "center",
      "normalized",
      "onesided",
      "length",
      "return_complex"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.kl_div": {},
  "torch.kron": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.kron",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.kthvalue": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.kthvalue",
    "min_input_args": 2,
    "args_list": [
      "input",
      "k",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.lcm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.lcm",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.ldexp": {
    "Matcher": "LdExpMatcher",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.le": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.less_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.lerp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.lerp",
    "min_input_args": 3,
    "args_list": [
      "input",
      "end",
      "weight",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "end": "y"
    }
  },
  "torch.less": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.less_than",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.less_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.less_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.lgamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.lgamma",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.cholesky": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.cholesky",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "upper",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.cholesky_ex": {},
  "torch.linalg.cond": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.cond",
    "min_input_args": 1,
    "args_list": [
      "input",
      "p",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.cross": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.cross",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "dim",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y",
      "dim": "axis"
    },
    "paddle_default_kwargs": {
      "axis": -1
    }
  },
  "torch.linalg.det": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.det",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.linalg.diagonal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.diagonal",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "offset",
      "dim1",
      "dim2"
    ],
    "kwargs_change": {
      "A": "x",
      "dim1": "axis1",
      "dim2": "axis2"
    },
    "paddle_default_kwargs": {
      "axis1": -2,
      "axis2": -1
    }
  },
  "torch.linalg.eig": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.linalg.eig",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.eigh": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.linalg.eigh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "UPLO",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.eigvals": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.eigvals",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.eigvalsh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.eigvalsh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "UPLO",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.householder_product": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.householder_product",
    "min_input_args": 2,
    "args_list": [
      "input",
      "tau",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.inv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.inv",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.linalg.inv_ex": {},
  "torch.linalg.ldl_factor": {},
  "torch.linalg.ldl_factor_ex": {},
  "torch.linalg.ldl_solve": {},
  "torch.linalg.lstsq": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.lstsq",
    "min_input_args": 2,
    "args_list": [
      "input",
      "b",
      "rcond",
      "*",
      "driver"
    ],
    "kwargs_change": {
      "input": "x",
      "b": "y"
    }
  },
  "torch.linalg.lu": {
    "Matcher": "LinalgLuMatcher",
    "paddle_api": "paddle.linalg.lu",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "pivot",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.linalg.lu_factor": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.linalg.lu",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "pivot",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.linalg.lu_factor_ex": {
    "Matcher": "TripleAssignMatcher",
    "paddle_api": "paddle.linalg.lu",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "pivot",
      "check_errors",
      "out"
    ],
    "kwargs_change": {
      "A": "x",
      "check_errors": ""
    },
    "paddle_default_kwargs": {
      "get_infos": "True"
    }
  },
  "torch.linalg.lu_solve": {},
  "torch.linalg.matmul": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.matmul",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.linalg.matrix_exp": {},
  "torch.linalg.matrix_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.matrix_norm",
    "min_input_args": 1,
    "args_list": [
      "input",
      "ord",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "ord": "p",
      "dim": "axis"
    }
  },
  "torch.linalg.matrix_power": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.matrix_power",
    "min_input_args": 2,
    "args_list": [
      "input",
      "n",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.linalg.matrix_rank": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.matrix_rank",
    "min_input_args": 1,
    "args_list": [
      "A",
      "tol",
      "hermitian",
      "*",
      "atol",
      "rtol",
      "hermitian",
      "out"
    ],
    "kwargs_change": {
      "A": "x",
      "atol": "tol",
      "rtol": ""
    }
  },
  "torch.linalg.multi_dot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.multi_dot",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x"
    }
  },
  "torch.linalg.norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.norm",
    "min_input_args": 1,
    "args_list": [
      "input",
      "ord",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "ord": "p",
      "dim": "axis"
    }
  },
  "torch.linalg.pinv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.pinv",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "atol",
      "rtol",
      "hermitian",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "atol": "",
      "rtol": "rcond"
    }
  },
  "torch.linalg.qr": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.linalg.qr",
    "min_input_args": 1,
    "args_list": [
      "A",
      "mode",
      "*",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.linalg.slogdet": {
    "Matcher": "SLogDetMatcher",
    "paddle_api": "paddle.linalg.slogdet",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "out"
    ]
  },
  "torch.linalg.solve": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.solve",
    "min_input_args": 2,
    "args_list": [
      "A",
      "B",
      "*",
      "left",
      "out"
    ],
    "kwargs_change": {
      "A": "x",
      "B": "y"
    },
    "unsupport_args": [
      "left"
    ]
  },
  "torch.linalg.solve_ex": {},
  "torch.linalg.solve_triangular": {
    "Matcher": "LinalgSolveTriangularMatcher",
    "paddle_api": "paddle.linalg.triangular_solve",
    "min_input_args": 2,
    "args_list": [
      "input",
      "B",
      "*",
      "upper",
      "left",
      "unitriangular",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "B": "y",
      "left": "transpose"
    }
  },
  "torch.linalg.svd": {
    "Matcher": "TripleAssignMatcher",
    "paddle_api": "paddle.linalg.svd",
    "min_input_args": 1,
    "args_list": [
      "A",
      "full_matrices",
      "*",
      "driver",
      "out"
    ],
    "kwargs_change": {
      "A": "x",
      "driver": ""
    },
    "paddle_default_kwargs": {
      "full_matrices": "True"
    }
  },
  "torch.linalg.svdvals": {
    "Matcher": "LinalgSvdvalsMatcher",
    "paddle_api": "paddle.linalg.svd",
    "min_input_args": 1,
    "args_list": [
      "A",
      "*",
      "driver",
      "out"
    ],
    "kwargs_change": {
      "A": "x",
      "driver": ""
    }
  },
  "torch.linalg.tensorinv": {},
  "torch.linalg.tensorsolve": {},
  "torch.linalg.vander": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.vander",
    "min_input_args": 1,
    "args_list": [
      "x",
      "*",
      "N"
    ],
    "kwargs_change": {
      "N": "n"
    },
    "paddle_default_kwargs": {
      "increasing": "True"
    }
  },
  "torch.linalg.vecdot": {},
  "torch.linalg.vector_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.vector_norm",
    "min_input_args": 1,
    "args_list": [
      "x",
      "ord",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "ord": "p",
      "dim": "axis"
    }
  },
  "torch.linspace": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linspace",
    "min_input_args": 3,
    "args_list": [
      "start",
      "end",
      "steps",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "end": "stop",
      "steps": "num",
      "dtype": "dtype"
    }
  },
  "torch.load": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.load",
    "min_input_args": 1,
    "args_list": [
      "f",
      "map_location",
      "pickle_module",
      "*",
      "weights_only",
      "mmap",
      "**pickle_load_args"
    ],
    "kwargs_change": {
      "f": "path",
      "map_location": "",
      "pickle_module": "",
      "weights_only": ""
    },
    "unsupport_args": [
      "mmap"
    ]
  },
  "torch.log": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.log",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.log10": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.log10",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.log1p": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.log1p",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.log2": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.log2",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.log_softmax": {},
  "torch.logaddexp": {
    "Matcher": "LogAddExpMatcher",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.logaddexp2": {
    "Matcher": "LogAddExp2Matcher",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.logcumsumexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logcumsumexp",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.logdet": {
    "Matcher": "LogDetMatcher",
    "min_input_args": 1,
    "args_list": [
      "input"
    ]
  },
  "torch.logical_and": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logical_and",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.logical_not": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logical_not",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.logical_or": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logical_or",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.logical_xor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logical_xor",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.logspace": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logspace",
    "min_input_args": 3,
    "args_list": [
      "start",
      "end",
      "steps",
      "base",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "kwargs_change": {
      "end": "stop",
      "steps": "num",
      "dtype": "dtype"
    }
  },
  "torch.lstsq": {
    "min_input_args": 2
  },
  "torch.lt": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.less_than",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.lu": {
    "Matcher": "LuMatcher",
    "paddle_api": "paddle.linalg.lu",
    "min_input_args": 1,
    "args_list": [
      "A",
      "pivot",
      "get_infos",
      "out"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.lu_solve": {},
  "torch.lu_unpack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.lu_unpack",
    "min_input_args": 2,
    "args_list": [
      "LU_data",
      "LU_pivots",
      "unpack_data",
      "unpack_pivots",
      "*",
      "out"
    ],
    "kwargs_change": {
      "LU_data": "x",
      "LU_pivots": "y",
      "unpack_data": "unpack_ludata"
    }
  },
  "torch.manual_seed": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.seed",
    "min_input_args": 1,
    "args_list": [
      "seed"
    ]
  },
  "torch.margin_ranking_loss": {},
  "torch.masked_fill": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.masked_fill",
    "min_input_args": 3,
    "args_list": [
      "input",
      "mask",
      "value"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.masked_select": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.masked_select",
    "min_input_args": 2,
    "args_list": [
      "input",
      "mask",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.matrix_rank": {
    "min_input_args": 1
  },
  "torch.max": {
    "Matcher": "MaxMinMatcher",
    "paddle_api": "paddle.max",
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.max_pool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool1d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "dilation"
    ]
  },
  "torch.max_pool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool2d",
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "dilation"
    ]
  },
  "torch.max_pool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool3d",
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "dilation"
    ]
  },
  "torch.maximum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.maximum",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.mean": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.mean",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.median": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.median",
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "unsupport_args": [
      "dim"
    ]
  },
  "torch.meshgrid": {
    "Matcher": "MeshgridMatcher",
    "paddle_api": "paddle.meshgrid",
    "min_input_args": 2,
    "args_list": [
      "*tensors",
      "indexing"
    ]
  },
  "torch.min": {
    "Matcher": "MaxMinMatcher",
    "paddle_api": "paddle.min",
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.minimum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.minimum",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.mm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.mm",
    "min_input_args": 2,
    "args_list": [
      "input",
      "mat2",
      "*",
      "out"
    ]
  },
  "torch.mode": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.mode",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.moveaxis": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.moveaxis",
    "min_input_args": 3,
    "args_list": [
      "input",
      "source",
      "destination"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.movedim": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.moveaxis",
    "min_input_args": 3,
    "args_list": [
      "input",
      "source",
      "destination"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.msort": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sort",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "paddle_default_kwargs": {
      "axis": 0
    }
  },
  "torch.multinomial": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.multinomial",
    "min_input_args": 2,
    "args_list": [
      "input",
      "num_samples",
      "replacement",
      "*",
      "generator",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.multiply": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.multiply",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.multiprocessing.spawn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.distributed.spawn",
    "min_input_args": 1,
    "args_list": [
      "fn",
      "args",
      "nprocs",
      "join",
      "daemon",
      "start_method"
    ],
    "kwargs_change": {
      "fn": "func",
      "start_method": ""
    },
    "paddle_default_kwargs": {
      "nprocs": "1"
    }
  },
  "torch.mv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.mv",
    "min_input_args": 2,
    "args_list": [
      "input",
      "vec",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nan_to_num": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nan_to_num",
    "min_input_args": 1,
    "args_list": [
      "input",
      "nan",
      "posinf",
      "neginf",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nanmean": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nanmean",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.nanmedian": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nanmedian",
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "unsupport_args": [
      "dim"
    ]
  },
  "torch.nanquantile": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nanquantile",
    "args_list": [
      "input",
      "q",
      "dim",
      "keepdim",
      "*",
      "interpolation",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.nansum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nansum",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.narrow": {
    "Matcher": "NarrowMatcher",
    "paddle_api": "paddle.slice",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "start",
      "length"
    ]
  },
  "torch.narrow_copy": {
    "Matcher": "NarrowCopyMatcher",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "start",
      "length",
      "*",
      "out"
    ]
  },
  "torch.ne": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.not_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.neg": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.neg",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.negative": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.neg",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nextafter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nextafter",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.nn.AdaptiveAvgPool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveAvgPool1D",
    "min_input_args": 1,
    "args_list": [
      "output_size"
    ]
  },
  "torch.nn.AdaptiveAvgPool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveAvgPool2D",
    "min_input_args": 1,
    "args_list": [
      "output_size"
    ]
  },
  "torch.nn.AdaptiveAvgPool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveAvgPool3D",
    "min_input_args": 1,
    "args_list": [
      "output_size"
    ]
  },
  "torch.nn.AdaptiveMaxPool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveMaxPool1D",
    "min_input_args": 1,
    "args_list": [
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    }
  },
  "torch.nn.AdaptiveMaxPool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveMaxPool2D",
    "min_input_args": 1,
    "args_list": [
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    }
  },
  "torch.nn.AdaptiveMaxPool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AdaptiveMaxPool3D",
    "min_input_args": 1,
    "args_list": [
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    }
  },
  "torch.nn.AlphaDropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.AlphaDropout",
    "min_input_args": 0,
    "args_list": [
      "p",
      "inplace"
    ]
  },
  "torch.nn.AvgPool1d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.AvgPool1D",
    "min_input_args": 1,
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad"
    ]
  },
  "torch.nn.AvgPool2d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.AvgPool2D",
    "min_input_args": 1,
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ]
  },
  "torch.nn.AvgPool3d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.AvgPool3D",
    "min_input_args": 1,
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ]
  },
  "torch.nn.BCELoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.BCELoss",
    "min_input_args": 0,
    "args_list": [
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.BCEWithLogitsLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.BCEWithLogitsLoss",
    "min_input_args": 0,
    "args_list": [
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ]
  },
  "torch.nn.BatchNorm1d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.BatchNorm1D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.BatchNorm2d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.BatchNorm2D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.BatchNorm3d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.BatchNorm3D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.Bilinear": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Bilinear",
    "min_input_args": 3,
    "args_list": [
      "in1_features",
      "in2_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.CELU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.CELU",
    "min_input_args": 0,
    "args_list": [
      "alpha",
      "inplace"
    ]
  },
  "torch.nn.ChannelShuffle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ChannelShuffle",
    "min_input_args": 1,
    "args_list": [
      "groups"
    ]
  },
  "torch.nn.ConstantPad1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad1D",
    "min_input_args": 2,
    "args_list": [
      "padding",
      "value"
    ]
  },
  "torch.nn.ConstantPad2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad2D",
    "min_input_args": 2,
    "args_list": [
      "padding",
      "value"
    ]
  },
  "torch.nn.ConstantPad3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad3D",
    "min_input_args": 2,
    "args_list": [
      "padding",
      "value"
    ]
  },
  "torch.nn.Conv1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv1D",
    "min_input_args": 3,
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.Conv2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv2D",
    "min_input_args": 3,
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.Conv3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv3D",
    "min_input_args": 3,
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.ConvTranspose1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv1DTranspose",
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "unsupport_args": [
      "padding_mode"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 3
  },
  "torch.nn.ConvTranspose2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv2DTranspose",
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "unsupport_args": [
      "padding_mode"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 3
  },
  "torch.nn.ConvTranspose3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Conv3DTranspose",
    "args_list": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "unsupport_args": [
      "padding_mode"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 3
  },
  "torch.nn.CosineEmbeddingLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.CosineEmbeddingLoss",
    "min_input_args": 0,
    "args_list": [
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.CosineSimilarity": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.CosineSimilarity",
    "min_input_args": 0,
    "args_list": [
      "dim",
      "eps"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.nn.CrossEntropyLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.CrossEntropyLoss",
    "args_list": [
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction",
      "label_smoothing"
    ],
    "unsupport_args": [
      "label_smoothing"
    ],
    "min_input_args": 0
  },
  "torch.nn.DataParallel": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.DataParallel",
    "args_list": [
      "module",
      "device_ids",
      "output_device",
      "dim"
    ],
    "kwargs_change": {
      "module": "layers",
      "device_ids": "",
      "output_device": ""
    },
    "unsupport_args": [
      "dim"
    ],
    "min_input_args": 0
  },
  "torch.nn.Dropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Dropout",
    "min_input_args": 0,
    "args_list": [
      "p",
      "inplace"
    ]
  },
  "torch.nn.Dropout1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Dropout",
    "min_input_args": 0,
    "args_list": [
      "p",
      "inplace"
    ]
  },
  "torch.nn.Dropout2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Dropout2D",
    "min_input_args": 0,
    "args_list": [
      "p",
      "inplace"
    ]
  },
  "torch.nn.Dropout3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Dropout3D",
    "min_input_args": 0,
    "args_list": [
      "p",
      "inplace"
    ]
  },
  "torch.nn.ELU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ELU",
    "min_input_args": 0,
    "args_list": [
      "alpha",
      "inplace"
    ]
  },
  "torch.nn.Embedding": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Embedding",
    "args_list": [
      "num_embeddings",
      "embedding_dim",
      "padding_idx",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "sparse"
    ],
    "unsupport_args": [
      "max_norm",
      "norm_type",
      "scale_grad_by_freq"
    ],
    "min_input_args": 2
  },
  "torch.nn.Flatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Flatten",
    "min_input_args": 0,
    "args_list": [
      "start_dim",
      "end_dim"
    ],
    "kwargs_change": {
      "start_dim": "start_axis",
      "end_dim": "stop_axis"
    }
  },
  "torch.nn.Fold": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Fold",
    "min_input_args": 2,
    "args_list": [
      "output_size",
      "kernel_size",
      "stride",
      "padding",
      "dilation"
    ],
    "kwargs_change": {
      "output_size": "output_sizes",
      "kernel_size": "kernel_sizes",
      "stride": "strides",
      "padding": "paddings",
      "dilation": "dilations"
    }
  },
  "torch.nn.GELU": {
    "Matcher": "GeluMatcher",
    "paddle_api": "paddle.nn.GELU",
    "min_input_args": 0,
    "args_list": [
      "approximate"
    ]
  },
  "torch.nn.GRU": {
    "Matcher": "RNNMatcher",
    "paddle_api": "paddle.nn.GRU",
    "args_list": [
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 0
  },
  "torch.nn.GRUCell": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.GRUCell",
    "args_list": [
      "input_size",
      "hidden_size",
      "bias",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 2
  },
  "torch.nn.GaussianNLLLoss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.GaussianNLLLoss",
    "min_input_args": 0,
    "args_list": [
      "*",
      "full",
      "eps",
      "reduction"
    ],
    "kwargs_change": {
      "eps": "epsilon"
    }
  },
  "torch.nn.GroupNorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.GroupNorm",
    "args_list": [
      "num_groups",
      "num_channels",
      "eps",
      "affine",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 2
  },
  "torch.nn.Hardshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Hardshrink",
    "min_input_args": 1,
    "args_list": [
      "lambd"
    ],
    "kwargs_change": {
      "lambd": "threshold"
    }
  },
  "torch.nn.Hardsigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Hardsigmoid",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.Hardswish": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Hardswish",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.Hardtanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Hardtanh",
    "min_input_args": 0,
    "args_list": [
      "min_val",
      "max_val",
      "inplace"
    ],
    "kwargs_change": {
      "min_val": "min",
      "max_val": "max"
    }
  },
  "torch.nn.HingeEmbeddingLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.HingeEmbeddingLoss",
    "min_input_args": 0,
    "args_list": [
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.HuberLoss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.SmoothL1Loss",
    "min_input_args": 0,
    "args_list": [
      "reduction",
      "delta"
    ]
  },
  "torch.nn.Identity": {
    "Matcher": "UnchangeMatcher",
    "paddle_api": "paddle.nn.Identity",
    "min_input_args": 0,
    "args_list": [
      "*args",
      "**kwargs"
    ]
  },
  "torch.nn.InstanceNorm1d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.InstanceNorm1D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.InstanceNorm2d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.InstanceNorm2D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.InstanceNorm3d": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.InstanceNorm3D",
    "min_input_args": 1,
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    }
  },
  "torch.nn.KLDivLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.KLDivLoss",
    "args_list": [
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "unsupport_args": [
      "log_target"
    ],
    "min_input_args": 0
  },
  "torch.nn.L1Loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.L1Loss",
    "args_list": [
      "size_average",
      "reduce",
      "reduction"
    ],
    "min_input_args": 0
  },
  "torch.nn.LSTM": {
    "Matcher": "RNNMatcher",
    "paddle_api": "paddle.nn.LSTM",
    "args_list": [
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "proj_size",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "unsupport_args": [
      "proj_size"
    ],
    "min_input_args": 0
  },
  "torch.nn.LSTMCell": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LSTMCell",
    "args_list": [
      "input_size",
      "hidden_size",
      "bias",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 2
  },
  "torch.nn.LayerNorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LayerNorm",
    "args_list": [
      "normalized_shape",
      "eps",
      "elementwise_affine",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "elementwise_affine": [
        "weight_attr",
        "bias_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 1
  },
  "torch.nn.LeakyReLU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LeakyReLU",
    "args_list": [
      "negative_slope",
      "inplace"
    ],
    "min_input_args": 0
  },
  "torch.nn.Linear": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Linear",
    "args_list": [
      "in_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 2
  },
  "torch.nn.LocalResponseNorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LocalResponseNorm",
    "args_list": [
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "min_input_args": 1
  },
  "torch.nn.LogSigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LogSigmoid",
    "min_input_args": 0
  },
  "torch.nn.LogSoftmax": {
    "Matcher": "SoftmaxMatcher",
    "paddle_api": "paddle.nn.LogSoftmax",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.nn.MSELoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.MSELoss",
    "min_input_args": 0,
    "args_list": [
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.MarginRankingLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.MarginRankingLoss",
    "args_list": [
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "min_input_args": 0
  },
  "torch.nn.MaxPool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxPool1D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 1
  },
  "torch.nn.MaxPool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxPool2D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 1
  },
  "torch.nn.MaxPool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxPool3D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "kwargs_change": {
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 1
  },
  "torch.nn.MaxUnpool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxUnPool1D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding"
    ],
    "min_input_args": 1
  },
  "torch.nn.MaxUnpool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxUnPool2D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding"
    ],
    "min_input_args": 1
  },
  "torch.nn.MaxUnpool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.MaxUnPool3D",
    "args_list": [
      "kernel_size",
      "stride",
      "padding"
    ],
    "min_input_args": 1
  },
  "torch.nn.Mish": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Mish",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.Module": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer",
    "abstract": true,
    "min_input_args": 0
  },
  "torch.nn.Module.add_module": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.add_sublayer",
    "min_input_args": 2,
    "args_list": [
      "name",
      "module"
    ],
    "kwargs_change": {
      "module": "sublayer"
    }
  },
  "torch.nn.Module.apply": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 1,
    "args_list": [
      "fn"
    ]
  },
  "torch.nn.Module.bfloat16": {
    "min_input_args": 0
  },
  "torch.nn.Module.buffers": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.buffers",
    "min_input_args": 0,
    "args_list": [
      "recurse"
    ],
    "kwargs_change": {
      "recurse": "include_sublayers"
    }
  },
  "torch.nn.Module.children": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.children",
    "min_input_args": 0
  },
  "torch.nn.Module.cpu": {
    "min_input_args": 0
  },
  "torch.nn.Module.cuda": {
    "min_input_args": 0
  },
  "torch.nn.Module.double": {
    "min_input_args": 0
  },
  "torch.nn.Module.eval": {
    "Matcher": "UnchangeMatcher",
    "min_input_args": 0
  },
  "torch.nn.Module.float": {
    "min_input_args": 0
  },
  "torch.nn.Module.get_buffer": {
    "Matcher": "ModuleGetSubMatcher",
    "min_input_args": 1,
    "args_list": [
      "target"
    ]
  },
  "torch.nn.Module.get_extra_state": {
    "min_input_args": 0
  },
  "torch.nn.Module.get_parameter": {
    "Matcher": "ModuleGetSubMatcher",
    "min_input_args": 1,
    "args_list": [
      "target"
    ]
  },
  "torch.nn.Module.get_submodule": {
    "Matcher": "ModuleGetSubMatcher",
    "min_input_args": 1,
    "args_list": [
      "target"
    ]
  },
  "torch.nn.Module.half": {
    "min_input_args": 0
  },
  "torch.nn.Module.ipu": {
    "min_input_args": 0
  },
  "torch.nn.Module.load_state_dict": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.set_state_dict",
    "args_list": [
      "state_dict",
      "strict"
    ],
    "kwargs_change": {
      "strict": "use_structured_name"
    },
    "min_input_args": 1
  },
  "torch.nn.Module.modules": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.sublayers",
    "min_input_args": 0
  },
  "torch.nn.Module.named_buffers": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.named_buffers",
    "args_list": [
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "kwargs_change": {
      "recurse": "include_sublayers",
      "remove_duplicate": ""
    },
    "min_input_args": 0
  },
  "torch.nn.Module.named_children": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.named_children",
    "min_input_args": 0
  },
  "torch.nn.Module.named_modules": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.named_sublayers",
    "args_list": [
      "memo",
      "prefix",
      "remove_duplicate"
    ],
    "unsupport_args": [
      "memo",
      "remove_duplicate"
    ],
    "min_input_args": 0
  },
  "torch.nn.Module.named_parameters": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.named_parameters",
    "min_input_args": 0,
    "args_list": [
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "kwargs_change": {
      "recurse": "include_sublayers",
      "remove_duplicate": ""
    }
  },
  "torch.nn.Module.parameters": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.parameters",
    "args_list": [
      "recurse"
    ],
    "kwargs_change": {
      "recurse": "include_sublayers"
    },
    "min_input_args": 0
  },
  "torch.nn.Module.register_backward_hook": {
    "min_input_args": 1
  },
  "torch.nn.Module.register_buffer": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.register_buffer",
    "min_input_args": 2,
    "args_list": [
      "name",
      "tensor",
      "persistent"
    ],
    "kwargs_change": {
      "persistent": "persistable"
    }
  },
  "torch.nn.Module.register_forward_hook": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.register_forward_post_hook",
    "args_list": [
      "hook",
      "*",
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "unsupport_args": [
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "min_input_args": 1
  },
  "torch.nn.Module.register_forward_pre_hook": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.register_forward_pre_hook",
    "args_list": [
      "hook",
      "*",
      "prepend",
      "with_kwargs"
    ],
    "unsupport_args": [
      "prepend",
      "with_kwargs"
    ],
    "min_input_args": 1
  },
  "torch.nn.Module.register_full_backward_hook": {
    "min_input_args": 1
  },
  "torch.nn.Module.register_full_backward_pre_hook": {
    "min_input_args": 1
  },
  "torch.nn.Module.register_load_state_dict_post_hook": {
    "min_input_args": 1
  },
  "torch.nn.Module.register_module": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.add_sublayer",
    "min_input_args": 2,
    "args_list": [
      "name",
      "module"
    ],
    "kwargs_change": {
      "module": "sublayer"
    }
  },
  "torch.nn.Module.register_parameter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.add_parameter",
    "min_input_args": 2,
    "args_list": [
      "name",
      "param"
    ],
    "kwargs_change": {
      "param": "parameter"
    }
  },
  "torch.nn.Module.requires_grad_": {
    "min_input_args": 0
  },
  "torch.nn.Module.set_extra_state": {
    "min_input_args": 1
  },
  "torch.nn.Module.share_memory": {
    "min_input_args": 0
  },
  "torch.nn.Module.state_dict": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.state_dict",
    "min_input_args": 0,
    "args_list": [
      "*",
      "destination",
      "prefix",
      "keep_vars"
    ],
    "unsupport_args": [
      "destination",
      "prefix",
      "keep_vars"
    ]
  },
  "torch.nn.Module.to": {
    "min_input_args": 0
  },
  "torch.nn.Module.to_empty": {
    "min_input_args": 0
  },
  "torch.nn.Module.train": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.train",
    "min_input_args": 0
  },
  "torch.nn.Module.type": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Layer.astype",
    "min_input_args": 1,
    "args_list": [
      "dst_type"
    ],
    "kwargs_change": {
      "dst_type": "dtype"
    }
  },
  "torch.nn.Module.xpu": {
    "min_input_args": 0
  },
  "torch.nn.Module.zero_grad": {
    "min_input_args": 0
  },
  "torch.nn.ModuleDict": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LayerDict",
    "args_list": [
      "modules"
    ],
    "kwargs_change": {
      "modules": "sublayers"
    },
    "min_input_args": 0
  },
  "torch.nn.ModuleList": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.LayerList",
    "args_list": [
      "modules"
    ],
    "kwargs_change": {
      "modules": "sublayers"
    },
    "min_input_args": 0
  },
  "torch.nn.MultiLabelSoftMarginLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.MultiLabelSoftMarginLoss",
    "min_input_args": 0,
    "args_list": [
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.MultiMarginLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.MultiMarginLoss",
    "min_input_args": 0,
    "args_list": [
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.MultiheadAttention": {
    "paddle_api": "paddle.nn.MultiHeadAttention",
    "args_list": [
      "embed_dim",
      "num_heads",
      "dropout",
      "bias",
      "add_bias_kv",
      "add_zero_attn",
      "kdim",
      "vdim",
      "batch_first",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": "bias_attr",
      "device": "",
      "dtype": ""
    },
    "unsupport_args": [
      "add_bias_kv",
      "add_zero_attn",
      "batch_first"
    ],
    "paddle_default_kwargs": {
      "need_weights": "True"
    },
    "min_input_args": 2
  },
  "torch.nn.NLLLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.NLLLoss",
    "min_input_args": 0,
    "args_list": [
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ]
  },
  "torch.nn.PReLU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.PReLU",
    "args_list": [
      "num_parameters",
      "init",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "device": "",
      "dtype": ""
    },
    "min_input_args": 0
  },
  "torch.nn.PairwiseDistance": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.PairwiseDistance",
    "min_input_args": 0,
    "args_list": [
      "p",
      "eps",
      "keepdim"
    ],
    "kwargs_change": {
      "eps": "epsilon"
    }
  },
  "torch.nn.Parameter": {
    "Matcher": "ParameterMatcher",
    "args_list": [
      "data",
      "requires_grad"
    ],
    "min_input_args": 1
  },
  "torch.nn.ParameterList": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ParameterList",
    "args_list": [
      "values"
    ],
    "kwargs_change": {
      "values": "parameters"
    },
    "min_input_args": 0
  },
  "torch.nn.PixelShuffle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.PixelShuffle",
    "min_input_args": 1,
    "args_list": [
      "upscale_factor"
    ]
  },
  "torch.nn.PixelUnshuffle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.PixelUnshuffle",
    "min_input_args": 1,
    "args_list": [
      "downscale_factor"
    ]
  },
  "torch.nn.PoissonNLLLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.PoissonNLLLoss",
    "min_input_args": 0,
    "args_list": [
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "eps": "epsilon"
    }
  },
  "torch.nn.RNN": {
    "Matcher": "RNNMatcher",
    "paddle_api": "paddle.nn.SimpleRNN",
    "args_list": [
      "input_size",
      "hidden_size",
      "num_layers",
      "nonlinearity",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "nonlinearity": "activation",
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "device": "",
      "dtype": ""
    },
    "min_input_args": 0
  },
  "torch.nn.RNNBase": {
    "Matcher": "RNNBaseMatcher",
    "paddle_api": "paddle.nn.layer.rnn.RNNBase",
    "args_list": [
      "mode",
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "proj_size",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ]
    },
    "unsupport_args": [
      "proj_size"
    ],
    "min_input_args": 3
  },
  "torch.nn.RNNCell": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.SimpleRNNCell",
    "args_list": [
      "input_size",
      "hidden_size",
      "bias",
      "nonlinearity",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "bias": [
        "bias_ih_attr",
        "bias_hh_attr"
      ],
      "nonlinearity": "activation",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 2
  },
  "torch.nn.RReLU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.RReLU",
    "min_input_args": 0,
    "args_list": [
      "lower",
      "upper",
      "inplace"
    ]
  },
  "torch.nn.ReLU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ReLU",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.ReLU6": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ReLU6",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.ReflectionPad1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad1D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'reflect'"
    }
  },
  "torch.nn.ReflectionPad2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad2D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'reflect'"
    }
  },
  "torch.nn.ReflectionPad3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad3D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'reflect'"
    }
  },
  "torch.nn.ReplicationPad1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad1D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'replicate'"
    }
  },
  "torch.nn.ReplicationPad2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad2D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'replicate'"
    }
  },
  "torch.nn.ReplicationPad3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Pad3D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ],
    "paddle_default_kwargs": {
      "mode": "'replicate'"
    }
  },
  "torch.nn.SELU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.SELU",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.Sequential": {
    "Matcher": "SequentialMatcher",
    "paddle_api": "paddle.nn.Sequential",
    "min_input_args": 1,
    "args_list": [
      "*args"
    ]
  },
  "torch.nn.SiLU": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Silu",
    "min_input_args": 0,
    "args_list": [
      "inplace"
    ]
  },
  "torch.nn.Sigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Sigmoid",
    "min_input_args": 0
  },
  "torch.nn.SmoothL1Loss": {
    "Matcher": "SmoothL1LossMatcher",
    "paddle_api": "paddle.nn.SmoothL1Loss",
    "min_input_args": 0,
    "args_list": [
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "kwargs_change": {
      "beta": "delta"
    }
  },
  "torch.nn.SoftMarginLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.SoftMarginLoss",
    "args_list": [
      "size_average",
      "reduce",
      "reduction"
    ],
    "min_input_args": 0
  },
  "torch.nn.Softmax": {
    "Matcher": "SoftmaxMatcher",
    "paddle_api": "paddle.nn.Softmax",
    "min_input_args": 0,
    "args_list": [
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.nn.Softmax2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Softmax",
    "paddle_default_kwargs": {
      "axis": -3
    },
    "min_input_args": 0
  },
  "torch.nn.Softplus": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Softplus",
    "min_input_args": 0,
    "args_list": [
      "beta",
      "threshold"
    ]
  },
  "torch.nn.Softshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Softshrink",
    "min_input_args": 0,
    "args_list": [
      "lambd"
    ],
    "kwargs_change": {
      "lambd": "threshold"
    }
  },
  "torch.nn.Softsign": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Softsign",
    "min_input_args": 0
  },
  "torch.nn.SyncBatchNorm": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.SyncBatchNorm",
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "process_group",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "process_group": "",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 1
  },
  "torch.nn.SyncBatchNorm.convert_sync_batchnorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.SyncBatchNorm.convert_sync_batchnorm",
    "args_list": [
      "module",
      "process_group"
    ],
    "kwargs_change": {
      "module": "layer"
    },
    "unsupport_args": [
      "process_group"
    ],
    "min_input_args": 1
  },
  "torch.nn.Tanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Tanh",
    "min_input_args": 0
  },
  "torch.nn.Tanhshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Tanhshrink",
    "min_input_args": 0
  },
  "torch.nn.Transformer": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Transformer",
    "args_list": [
      "d_model",
      "nhead",
      "num_encoder_layers",
      "num_decoder_layers",
      "dim_feedforward",
      "dropout",
      "activation",
      "custom_encoder",
      "custom_decoder",
      "layer_norm_eps",
      "batch_first",
      "norm_first",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "norm_first": "normalize_before",
      "device": "",
      "dtype": ""
    },
    "unsupport_args": [
      "layer_norm_eps",
      "batch_first"
    ],
    "min_input_args": 0
  },
  "torch.nn.TransformerDecoder": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.TransformerDecoder",
    "args_list": [
      "decoder_layer",
      "num_layers",
      "norm"
    ],
    "min_input_args": 2
  },
  "torch.nn.TransformerDecoderLayer": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.TransformerDecoderLayer",
    "args_list": [
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "layer_norm_eps",
      "batch_first",
      "norm_first",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "norm_first": "normalize_before",
      "device": "",
      "dtype": ""
    },
    "unsupport_args": [
      "layer_norm_eps",
      "batch_first"
    ],
    "paddle_default_kwargs": {
      "dim_feedforward": 2048
    },
    "min_input_args": 2
  },
  "torch.nn.TransformerEncoder": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.TransformerEncoder",
    "args_list": [
      "encoder_layer",
      "num_layers",
      "norm",
      "enable_nested_tensor",
      "mask_check"
    ],
    "kwargs_change": {
      "enable_nested_tensor": "",
      "mask_check": ""
    },
    "min_input_args": 2
  },
  "torch.nn.TransformerEncoderLayer": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.TransformerEncoderLayer",
    "args_list": [
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "layer_norm_eps",
      "batch_first",
      "norm_first",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "norm_first": "normalize_before",
      "device": "",
      "dtype": ""
    },
    "unsupport_args": [
      "layer_norm_eps",
      "batch_first"
    ],
    "paddle_default_kwargs": {
      "dim_feedforward": 2048
    },
    "min_input_args": 2
  },
  "torch.nn.TripletMarginLoss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.TripletMarginLoss",
    "args_list": [
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "eps": "epsilon"
    },
    "min_input_args": 0
  },
  "torch.nn.TripletMarginWithDistanceLoss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.TripletMarginWithDistanceLoss",
    "args_list": [
      "*",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "min_input_args": 0
  },
  "torch.nn.Unflatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Unflatten",
    "min_input_args": 2,
    "args_list": [
      "dim",
      "unflattened_size"
    ],
    "kwargs_change": {
      "dim": "axis",
      "unflattened_size": "shape"
    }
  },
  "torch.nn.Unfold": {
    "Matcher": "Tuple2ListMatcher",
    "paddle_api": "paddle.nn.Unfold",
    "args_list": [
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "kwargs_change": {
      "kernel_size": "kernel_sizes",
      "dilation": "dilations",
      "padding": "paddings",
      "stride": "strides"
    },
    "min_input_args": 1
  },
  "torch.nn.Upsample": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.Upsample",
    "args_list": [
      "size",
      "scale_factor",
      "mode",
      "align_corners"
    ],
    "unsupport_args": [
      "recompute_scale_factor"
    ],
    "min_input_args": 0
  },
  "torch.nn.UpsamplingBilinear2d": {
    "Matcher": "UpsampleMatcher",
    "paddle_api": "paddle.nn.UpsamplingBilinear2D",
    "args_list": [
      "size",
      "scale_factor"
    ],
    "min_input_args": 0
  },
  "torch.nn.UpsamplingNearest2d": {
    "Matcher": "UpsampleMatcher",
    "paddle_api": "paddle.nn.UpsamplingNearest2D",
    "args_list": [
      "size",
      "scale_factor"
    ],
    "min_input_args": 0
  },
  "torch.nn.ZeroPad2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.ZeroPad2D",
    "min_input_args": 1,
    "args_list": [
      "padding"
    ]
  },
  "torch.nn.functional._Reduction.get_enum": {
    "Matcher": "Get_EnumMatcher",
    "min_input_args": 1,
    "args_list": [
      "reduction"
    ]
  },
  "torch.nn.functional.adaptive_avg_pool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_avg_pool1d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.adaptive_avg_pool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_avg_pool2d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.adaptive_avg_pool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_avg_pool3d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.adaptive_max_pool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_max_pool1d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    }
  },
  "torch.nn.functional.adaptive_max_pool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_max_pool2d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    }
  },
  "torch.nn.functional.adaptive_max_pool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.adaptive_max_pool3d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "output_size",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    }
  },
  "torch.nn.functional.affine_grid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.affine_grid",
    "args_list": [
      "theta",
      "size",
      "align_corners"
    ],
    "kwargs_change": {
      "size": "out_shape"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.alpha_dropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.alpha_dropout",
    "args_list": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.avg_pool1d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.functional.avg_pool1d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad"
    ]
  },
  "torch.nn.functional.avg_pool2d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.functional.avg_pool2d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ]
  },
  "torch.nn.functional.avg_pool3d": {
    "Matcher": "AvgPoolMatcher",
    "paddle_api": "paddle.nn.functional.avg_pool3d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ]
  },
  "torch.nn.functional.batch_norm": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.functional.batch_norm",
    "args_list": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "training",
      "momentum",
      "eps"
    ],
    "kwargs_change": {
      "input": "x",
      "eps": "epsilon"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.bilinear": {
    "Matcher": "FunctionalBilinearMatcher",
    "paddle_api": "paddle.nn.functional.bilinear",
    "min_input_args": 3,
    "args_list": [
      "input1",
      "input2",
      "weight",
      "bias"
    ],
    "kwargs_change": {
      "input1": "x1",
      "input2": "x2"
    }
  },
  "torch.nn.functional.binary_cross_entropy": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.binary_cross_entropy",
    "args_list": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.binary_cross_entropy_with_logits": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.binary_cross_entropy_with_logits",
    "args_list": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "kwargs_change": {
      "input": "logit",
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.celu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.celu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "alpha",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv1d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv2d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv3d",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv_transpose1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv1d_transpose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "dilation"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv_transpose2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv2d_transpose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "dilation"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.conv_transpose3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.conv3d_transpose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "dilation"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.cosine_embedding_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.cosine_embedding_loss",
    "args_list": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.cosine_similarity": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.cosine_similarity",
    "min_input_args": 2,
    "args_list": [
      "x1",
      "x2",
      "dim",
      "eps"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.nn.functional.cross_entropy": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.cross_entropy",
    "args_list": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction",
      "label_smoothing"
    ],
    "kwargs_change": {
      "target": "label",
      "label_smoothing": "soft_label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.dropout": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.dropout",
    "min_input_args": 1,
    "args_list": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.dropout1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.dropout",
    "args_list": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.dropout2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.dropout2d",
    "args_list": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.dropout3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.dropout3d",
    "args_list": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.elu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.elu",
    "args_list": [
      "input",
      "alpha",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.elu_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.elu_",
    "min_input_args": 1,
    "args_list": [
      "input",
      "alpha"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.embedding": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.embedding",
    "args_list": [
      "input",
      "weight",
      "padding_idx",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "sparse"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "max_norm",
      "norm_type",
      "scale_grad_by_freq"
    ],
    "min_input_args": 2
  },
  "torch.nn.functional.fold": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.fold",
    "args_list": [
      "input",
      "output_size",
      "kernel_size",
      "stride",
      "padding",
      "dilation"
    ],
    "kwargs_change": {
      "input": "x",
      "output_size": "output_sizes",
      "kernel_size": "kernel_sizes",
      "stride": "strides",
      "padding": "paddings",
      "dilation": "dilations"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.gaussian_nll_loss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.gaussian_nll_loss",
    "min_input_args": 3,
    "args_list": [
      "input",
      "target",
      "var",
      "full",
      "eps",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label",
      "var": "variance",
      "eps": "epsilon"
    }
  },
  "torch.nn.functional.gelu": {
    "Matcher": "GeluMatcher",
    "paddle_api": "paddle.nn.functional.gelu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "approximate"
    ]
  },
  "torch.nn.functional.glu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.glu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.nn.functional.grid_sample": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.grid_sample",
    "args_list": [
      "input",
      "grid",
      "mode",
      "align_corners",
      "padding_mode"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.gumbel_softmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.gumbel_softmax",
    "min_input_args": 1,
    "args_list": [
      "logits",
      "tau",
      "hard",
      "eps",
      "dim"
    ],
    "kwargs_change": {
      "logits": "x",
      "tau": "temperature",
      "eps": "",
      "dim": "axis"
    }
  },
  "torch.nn.functional.hardshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.hardshrink",
    "min_input_args": 1,
    "args_list": [
      "input",
      "lambd"
    ],
    "kwargs_change": {
      "input": "x",
      "lambd": "threshold"
    }
  },
  "torch.nn.functional.hardsigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.hardsigmoid",
    "min_input_args": 1,
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.hardswish": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.hardswish",
    "min_input_args": 1,
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.hardtanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.hardtanh",
    "args_list": [
      "input",
      "min_val",
      "max_val",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x",
      "min_val": "min",
      "max_val": "max"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.hardtanh_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.hardtanh_",
    "min_input_args": 1,
    "args_list": [
      "input",
      "min_val",
      "max_val"
    ],
    "kwargs_change": {
      "input": "x",
      "min_val": "min",
      "max_val": "max"
    }
  },
  "torch.nn.functional.hinge_embedding_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.hinge_embedding_loss",
    "args_list": [
      "input",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.huber_loss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.smooth_l1_loss",
    "args_list": [
      "input",
      "target",
      "reduction",
      "delta"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.instance_norm": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.functional.instance_norm",
    "args_list": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "use_input_stats",
      "momentum",
      "eps"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.interpolate": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.interpolate",
    "args_list": [
      "input",
      "size",
      "scale_factor",
      "mode",
      "align_corners",
      "recompute_scale_factor",
      "antialias"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "recompute_scale_factor",
      "antialias"
    ],
    "min_input_args": 1
  },
  "torch.nn.functional.kl_div": {
    "Matcher": "FunctionalKLDivMatcher",
    "paddle_api": "paddle.nn.functional.kl_div",
    "args_list": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "unsupport_args": [
      "log_target"
    ],
    "min_input_args": 2
  },
  "torch.nn.functional.l1_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.l1_loss",
    "args_list": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.layer_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.layer_norm",
    "min_input_args": 2,
    "args_list": [
      "input",
      "normalized_shape",
      "weight",
      "bias",
      "eps"
    ],
    "kwargs_change": {
      "input": "x",
      "eps": "epsilon"
    }
  },
  "torch.nn.functional.leaky_relu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.leaky_relu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "negative_slope",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.leaky_relu_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.leaky_relu_",
    "min_input_args": 1,
    "args_list": [
      "input",
      "negative_slope"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.linear": {
    "Matcher": "FunctionalLinearMatcher",
    "paddle_api": "paddle.nn.functional.linear",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight",
      "bias"
    ]
  },
  "torch.nn.functional.local_response_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.local_response_norm",
    "min_input_args": 2,
    "args_list": [
      "input",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.log_softmax": {
    "Matcher": "RequireDimMatcher",
    "paddle_api": "paddle.nn.functional.log_softmax",
    "args_list": [
      "input",
      "dim",
      "_stacklevel",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "_stacklevel": "",
      "dtype": "dtype"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.logsigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.log_sigmoid",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.margin_ranking_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.margin_ranking_loss",
    "args_list": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "input1": "input",
      "input2": "other",
      "target": "label"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.max_pool1d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool1d",
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 0
  },
  "torch.nn.functional.max_pool2d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool2d",
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 0
  },
  "torch.nn.functional.max_pool3d": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.max_pool3d",
    "args_list": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "kwargs_change": {
      "input": "x",
      "return_indices": "return_mask"
    },
    "unsupport_args": [
      "dilation"
    ],
    "min_input_args": 0
  },
  "torch.nn.functional.max_unpool1d": {
    "Matcher": "UnpoolMatcher",
    "paddle_api": "paddle.nn.functional.max_unpool1d",
    "args_list": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "output_size"
    ],
    "min_input_args": 3
  },
  "torch.nn.functional.max_unpool2d": {
    "Matcher": "UnpoolMatcher",
    "paddle_api": "paddle.nn.functional.max_unpool2d",
    "args_list": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.max_unpool3d": {
    "Matcher": "UnpoolMatcher",
    "paddle_api": "paddle.nn.functional.max_unpool3d",
    "args_list": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.mish": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.mish",
    "min_input_args": 1,
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.mse_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.mse_loss",
    "args_list": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.multi_margin_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.multi_margin_loss",
    "args_list": [
      "input",
      "target",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.multilabel_soft_margin_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.multi_label_soft_margin_loss",
    "args_list": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.nll_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.nll_loss",
    "args_list": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.normalize": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.normalize",
    "args_list": [
      "input",
      "p",
      "dim",
      "eps",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "eps": "epsilon"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.one_hot": {
    "Matcher": "FunctionalOneHotMatcher",
    "paddle_api": "paddle.nn.functional.one_hot",
    "min_input_args": 1,
    "args_list": [
      "input",
      "num_classes"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.pad": {
    "Matcher": "FunctionalPadMatcher",
    "paddle_api": "paddle.nn.functional.pad",
    "min_input_args": 2,
    "args_list": [
      "input",
      "pad",
      "mode",
      "value"
    ]
  },
  "torch.nn.functional.pairwise_distance": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.pairwise_distance",
    "min_input_args": 2,
    "args_list": [
      "x1",
      "x2",
      "p",
      "eps",
      "keepdim"
    ],
    "kwargs_change": {
      "x1": "x",
      "x2": "y",
      "eps": "epsilon"
    }
  },
  "torch.nn.functional.pdist": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.pdist",
    "min_input_args": 1,
    "args_list": [
      "input",
      "p"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.pixel_shuffle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.pixel_shuffle",
    "min_input_args": 2,
    "args_list": [
      "input",
      "upscale_factor"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.pixel_unshuffle": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.pixel_unshuffle",
    "min_input_args": 2,
    "args_list": [
      "input",
      "downscale_factor"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.poisson_nll_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.poisson_nll_loss",
    "args_list": [
      "input",
      "target",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label",
      "eps": "epsilon"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.prelu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.prelu",
    "min_input_args": 2,
    "args_list": [
      "input",
      "weight"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.relu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.relu",
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.relu6": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.relu6",
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.relu_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.relu_",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.rrelu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.rrelu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "lower",
      "upper",
      "training",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.rrelu_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.rrelu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "lower",
      "upper",
      "training"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.selu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.selu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.sigmoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.sigmoid",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.silu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.silu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "inplace"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.smooth_l1_loss": {
    "Matcher": "FunctionalSmoothL1LossMatcher",
    "paddle_api": "paddle.nn.functional.smooth_l1_loss",
    "args_list": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.soft_margin_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.soft_margin_loss",
    "args_list": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "target": "label"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.softmax": {
    "Matcher": "RequireDimMatcher",
    "paddle_api": "paddle.nn.functional.softmax",
    "args_list": [
      "input",
      "dim",
      "_stacklevel",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "_stacklevel": "",
      "dtype": "dtype"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.softmin": {
    "Matcher": "FSoftMinMatcher",
    "paddle_api": "paddle.nn.functional.softmax",
    "args_list": [
      "input",
      "dim",
      "_stacklevel",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "_stacklevel": "",
      "dtype": "dtype"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.softplus": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.softplus",
    "min_input_args": 1,
    "args_list": [
      "input",
      "beta",
      "threshold"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.softshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.softshrink",
    "min_input_args": 1,
    "args_list": [
      "input",
      "lambd"
    ],
    "kwargs_change": {
      "input": "x",
      "lambd": "threshold"
    }
  },
  "torch.nn.functional.softsign": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.softsign",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.tanh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.tanh",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.tanhshrink": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.tanhshrink",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.nn.functional.triplet_margin_loss": {
    "Matcher": "SizeAverageMatcher",
    "paddle_api": "paddle.nn.functional.triplet_margin_loss",
    "min_input_args": 3,
    "args_list": [
      "anchor",
      "positive",
      "negative",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "kwargs_change": {
      "anchor": "input",
      "eps": "epsilon"
    }
  },
  "torch.nn.functional.triplet_margin_with_distance_loss": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.triplet_margin_with_distance_loss",
    "args_list": [
      "anchor",
      "positive",
      "negative",
      "*",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "kwargs_change": {
      "anchor": "input"
    },
    "min_input_args": 3
  },
  "torch.nn.functional.unfold": {
    "Matcher": "Tuple2ListMatcher",
    "paddle_api": "paddle.nn.functional.unfold",
    "args_list": [
      "input",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "kwargs_change": {
      "input": "x",
      "kernel_size": "kernel_sizes",
      "dilation": "dilations",
      "padding": "paddings",
      "stride": "strides"
    },
    "min_input_args": 2
  },
  "torch.nn.functional.upsample": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.upsample",
    "args_list": [
      "input",
      "size",
      "scale_factor",
      "mode",
      "align_corners"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "align_corners"
    ],
    "min_input_args": 1
  },
  "torch.nn.functional.upsample_bilinear": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.upsample",
    "args_list": [
      "input",
      "size",
      "scale_factor"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "paddle_default_kwargs": {
      "align_corners": "True",
      "mode": "'bilinear'"
    },
    "min_input_args": 1
  },
  "torch.nn.functional.upsample_nearest": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.upsample",
    "args_list": [
      "input",
      "size",
      "scale_factor"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "min_input_args": 1
  },
  "torch.nn.init.calculate_gain": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.initializer.calculate_gain",
    "min_input_args": 1,
    "args_list": [
      "nonlinearity",
      "param"
    ]
  },
  "torch.nn.init.constant_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Constant",
    "args_list": [
      "tensor",
      "val"
    ],
    "kwargs_change": {
      "val": "value"
    },
    "min_input_args": 2
  },
  "torch.nn.init.dirac_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Dirac",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "groups"
    ]
  },
  "torch.nn.init.eye_": {
    "Matcher": "InitEyeMatcher",
    "paddle_api": "paddle.nn.initializer.Assign",
    "min_input_args": 1,
    "args_list": [
      "tensor"
    ]
  },
  "torch.nn.init.kaiming_normal_": {
    "Matcher": "InitKaimingMatcher",
    "paddle_api": "paddle.nn.initializer.KaimingNormal",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "a",
      "mode",
      "nonlinearity"
    ],
    "kwargs_change": {
      "a": "negative_slope"
    },
    "paddle_default_kwargs": {
      "nonlinearity": "'leaky_relu'"
    }
  },
  "torch.nn.init.kaiming_uniform_": {
    "Matcher": "InitKaimingMatcher",
    "paddle_api": "paddle.nn.initializer.KaimingUniform",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "a",
      "mode",
      "nonlinearity"
    ],
    "kwargs_change": {
      "a": "negative_slope"
    },
    "paddle_default_kwargs": {
      "nonlinearity": "'leaky_relu'"
    }
  },
  "torch.nn.init.normal_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Normal",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "mean",
      "std"
    ]
  },
  "torch.nn.init.ones_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Constant",
    "min_input_args": 1,
    "args_list": [
      "tensor"
    ],
    "paddle_default_kwargs": {
      "value": "1.0"
    }
  },
  "torch.nn.init.orthogonal_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Orthogonal",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "gain"
    ]
  },
  "torch.nn.init.uniform_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Uniform",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "a",
      "b"
    ],
    "kwargs_change": {
      "a": "low",
      "b": "high"
    },
    "paddle_default_kwargs": {
      "low": "0.0"
    }
  },
  "torch.nn.init.xavier_normal_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.XavierNormal",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "gain"
    ],
    "unsupport_args": [
      "gain"
    ]
  },
  "torch.nn.init.xavier_uniform_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.XavierUniform",
    "min_input_args": 1,
    "args_list": [
      "tensor",
      "gain"
    ],
    "unsupport_args": [
      "gain"
    ]
  },
  "torch.nn.init.zeros_": {
    "Matcher": "InitMatcher",
    "paddle_api": "paddle.nn.initializer.Constant",
    "min_input_args": 1,
    "args_list": [
      "tensor"
    ],
    "paddle_default_kwargs": {
      "value": "0.0"
    }
  },
  "torch.nn.modules.batchnorm._BatchNorm": {
    "Matcher": "ReverseMomentumMatcher",
    "paddle_api": "paddle.nn.layer.norm._BatchNormBase",
    "args_list": [
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "kwargs_change": {
      "eps": "epsilon",
      "affine": [
        "weight_attr",
        "bias_attr"
      ],
      "track_running_stats": "",
      "device": "",
      "dtype": ""
    },
    "min_input_args": 1
  },
  "torch.nn.modules.utils._ntuple": {
    "Matcher": "NTupleMatcher",
    "args_list": [
      "n",
      "name"
    ],
    "min_input_args": 1
  },
  "torch.nn.modules.utils._pair": {
    "Matcher": "NTupleMatcher",
    "args_list": [
      "x"
    ],
    "paddle_default_kwargs": {
      "n": 2
    },
    "min_input_args": 1
  },
  "torch.nn.parallel.DistributedDataParallel": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.DataParallel",
    "args_list": [
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph"
    ],
    "kwargs_change": {
      "module": "layers",
      "device_ids": "",
      "bucket_cap_mb": "comm_buffer_size",
      "check_reduction": ""
    },
    "unsupport_args": [
      "output_device",
      "dim",
      "broadcast_buffers",
      "process_group",
      "gradient_as_bucket_view",
      "static_graph"
    ],
    "min_input_args": 1
  },
  "torch.nn.utils.clip_grad_norm_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.clip_grad_norm_",
    "args_list": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "kwargs_change": {
      "foreach": ""
    },
    "min_input_args": 2
  },
  "torch.nn.utils.clip_grad_value_": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.clip_grad_value_",
    "args_list": [
      "parameters",
      "clip_value",
      "foreach"
    ],
    "kwargs_change": {
      "foreach": ""
    },
    "min_input_args": 2
  },
  "torch.nn.utils.parameters_to_vector": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.parameters_to_vector",
    "args_list": [
      "parameters"
    ],
    "min_input_args": 1
  },
  "torch.nn.utils.parametrizations.spectral_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.spectral_norm",
    "args_list": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "kwargs_change": {
      "module": "layer"
    },
    "min_input_args": 1
  },
  "torch.nn.utils.remove_weight_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.remove_weight_norm",
    "args_list": [
      "module",
      "name"
    ],
    "kwargs_change": {
      "module": "layer"
    },
    "min_input_args": 1
  },
  "torch.nn.utils.spectral_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.spectral_norm",
    "min_input_args": 1,
    "args_list": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "kwargs_change": {
      "module": "layer"
    }
  },
  "torch.nn.utils.vector_to_parameters": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.vector_to_parameters",
    "args_list": [
      "vec",
      "parameters"
    ],
    "min_input_args": 2
  },
  "torch.nn.utils.weight_norm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.utils.weight_norm",
    "args_list": [
      "module",
      "name",
      "dim"
    ],
    "kwargs_change": {
      "module": "layer"
    },
    "min_input_args": 1
  },
  "torch.no_grad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.no_grad",
    "min_input_args": 0
  },
  "torch.nonzero": {
    "Matcher": "NonzeroMatcher",
    "paddle_api": "paddle.nonzero",
    "args_list": [
      "input",
      "*",
      "out",
      "as_tuple"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.norm": {
    "Matcher": "NormMatcher",
    "paddle_api": "paddle.linalg.norm",
    "args_list": [
      "input",
      "p",
      "dim",
      "keepdim",
      "out",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "min_input_args": 1
  },
  "torch.normal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.normal",
    "min_input_args": 1,
    "args_list": [
      "mean",
      "std",
      "size",
      "*",
      "generator",
      "out",
      "dtype",
      "layout",
      "device",
      "pin_memory",
      "requires_grad"
    ],
    "kwargs_change": {
      "size": "shape"
    }
  },
  "torch.not_equal": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.not_equal",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.numel": {
    "Matcher": "NumelMatcher",
    "paddle_api": "paddle.Tensor.size",
    "min_input_args": 1,
    "args_list": [
      "input"
    ]
  },
  "torch.ones": {
    "Matcher": "CreateMatcher",
    "paddle_api": "paddle.ones",
    "kwargs_change": {
      "dtype": "dtype"
    },
    "min_input_args": 1,
    "args_list": [
      "*size",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ]
  },
  "torch.ones_like": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.ones_like",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "torch.optim.Adadelta": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.Adadelta",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "rho",
      "eps",
      "weight_decay",
      "foreach",
      "*",
      "maximize",
      "differentiable"
    ],
    "unsupport_args": [
      "foreach",
      "maximize",
      "differentiable"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "eps": "epsilon"
    },
    "paddle_default_kwargs": {
      "rho": 0.9,
      "weight_decay": 0.0,
      "learning_rate": 1.0
    }
  },
  "torch.optim.Adagrad": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.Adagrad",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "lr_decay",
      "weight_decay",
      "initial_accumulator_value",
      "eps",
      "foreach",
      "*",
      "maximize",
      "differentiable"
    ],
    "unsupport_args": [
      "lr_decay",
      "foreach",
      "maximize",
      "differentiable"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "eps": "epsilon"
    },
    "paddle_default_kwargs": {
      "weight_decay": 0.0,
      "epsilon": 1e-10,
      "learning_rate": 0.01
    }
  },
  "torch.optim.Adam": {
    "Matcher": "OptimAdamMatcher",
    "paddle_api": "paddle.optimizer.Adam",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "betas",
      "eps",
      "weight_decay",
      "amsgrad",
      "*",
      "foreach",
      "maximize",
      "capturable",
      "differentiable",
      "fused"
    ],
    "unsupport_args": [
      "amsgrad",
      "foreach",
      "maximize",
      "capturable",
      "differentiable",
      "fused"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "eps": "epsilon"
    },
    "paddle_default_kwargs": {
      "weight_decay": 0.0
    }
  },
  "torch.optim.AdamW": {
    "Matcher": "OptimAdamMatcher",
    "paddle_api": "paddle.optimizer.AdamW",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "betas",
      "eps",
      "weight_decay",
      "amsgrad",
      "*",
      "maximize",
      "foreach",
      "capturable",
      "differentiable",
      "fused"
    ],
    "unsupport_args": [
      "amsgrad",
      "maximize",
      "foreach",
      "capturable",
      "differentiable",
      "fused"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "eps": "epsilon"
    },
    "paddle_default_kwargs": {
      "weight_decay": 0.0
    }
  },
  "torch.optim.Adamax": {
    "Matcher": "OptimAdamMatcher",
    "paddle_api": "paddle.optimizer.Adamax",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "betas",
      "eps",
      "weight_decay",
      "foreach",
      "*",
      "maximize",
      "differentiable"
    ],
    "unsupport_args": [
      "foreach",
      "maximize",
      "differentiable"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "eps": "epsilon"
    }
  },
  "torch.optim.LBFGS": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.LBFGS",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "max_iter",
      "max_eval",
      "tolerance_grad",
      "tolerance_change",
      "history_size",
      "line_search_fn"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate"
    }
  },
  "torch.optim.Optimizer": {
    "Matcher": "OptimOptimizerMatcher",
    "paddle_api": "paddle.optimizer.Optimizer",
    "min_input_args": 2,
    "args_list": [
      "params",
      "defaults"
    ]
  },
  "torch.optim.Optimizer.add_param_group": {
    "paddle_api": "paddle.optimizer.Optimizer._add_param_group",
    "min_input_args": 1
  },
  "torch.optim.Optimizer.load_state_dict": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.Optimizer.load_state_dict",
    "min_input_args": 1,
    "args_list": [
      "state_dict"
    ]
  },
  "torch.optim.Optimizer.step": {
    "Matcher": "UnchangeMatcher",
    "abstract": true,
    "min_input_args": 0
  },
  "torch.optim.Optimizer.zero_grad": {
    "min_input_args": 0
  },
  "torch.optim.RMSprop": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.RMSProp",
    "min_input_args": 1,
    "args_list": [
      "params",
      "lr",
      "alpha",
      "eps",
      "weight_decay",
      "momentum",
      "centered",
      "foreach",
      "maximize",
      "differentiable"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate",
      "alpha": "rho",
      "eps": "epsilon"
    },
    "unsupport_args": [
      "foreach",
      "maximize",
      "differentiable"
    ],
    "paddle_default_kwargs": {
      "weight_decay": 0.0,
      "epsilon": 1e-08,
      "learning_rate": 0.01,
      "rho": 0.99
    }
  },
  "torch.optim.SGD": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.optimizer.SGD",
    "min_input_args": 2,
    "args_list": [
      "params",
      "lr",
      "momentum",
      "dampening",
      "weight_decay",
      "nesterov",
      "*",
      "maximize",
      "foreach",
      "differentiable"
    ],
    "unsupport_args": [
      "momentum",
      "dampening",
      "nesterov",
      "maximize",
      "foreach",
      "differentiable"
    ],
    "kwargs_change": {
      "params": "parameters",
      "lr": "learning_rate"
    },
    "paddle_default_kwargs": {
      "weight_decay": 0.0
    }
  },
  "torch.optim.lr_scheduler.ConstantLR": {
    "Matcher": "ConstantLRMatcher",
    "paddle_api": "paddle.optimizer.lr.PiecewiseDecay",
    "min_input_args": 1,
    "args_list": [
      "optimizer",
      "factor",
      "total_iters",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.CosineAnnealingLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.CosineAnnealingDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "T_max",
      "eta_min",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.CosineAnnealingWarmRestarts": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.CosineAnnealingWarmRestarts",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "T_0",
      "T_mult",
      "eta_min",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.CyclicLR": {
    "Matcher": "LRSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.CyclicLR",
    "min_input_args": 3,
    "args_list": [
      "optimizer",
      "base_lr",
      "max_lr",
      "step_size_up",
      "step_size_down",
      "mode",
      "gamma",
      "scale_fn",
      "scale_mode",
      "cycle_momentum",
      "base_momentum",
      "max_momentum",
      "last_epoch",
      "verbose"
    ],
    "kwargs_change": {
      "base_lr": "base_learning_rate",
      "max_lr": "max_learning_rate",
      "gamma": "exp_gamma"
    },
    "unsupport_args": [
      "cycle_momentum",
      "base_momentum",
      "max_momentum"
    ],
    "paddle_default_kwargs": {
      "step_size_up": "2000"
    }
  },
  "torch.optim.lr_scheduler.ExponentialLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.ExponentialDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "gamma",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.LambdaLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.LambdaDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "lr_lambda",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.LinearLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.LinearLR",
    "min_input_args": 1,
    "args_list": [
      "optimizer",
      "start_factor",
      "end_factor",
      "total_iters",
      "last_epoch",
      "verbose"
    ],
    "kwargs_change": {
      "total_iters": "total_steps"
    },
    "paddle_default_kwargs": {
      "total_steps": "5"
    }
  },
  "torch.optim.lr_scheduler.MultiStepLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.MultiStepDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "milestones",
      "gamma",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.MultiplicativeLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.MultiplicativeDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "lr_lambda",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.optim.lr_scheduler.OneCycleLR": {
    "Matcher": "OneCycleLRMatcher",
    "paddle_api": "paddle.optimizer.lr.OneCycleLR",
    "min_input_args": 3,
    "args_list": [
      "optimizer",
      "max_lr",
      "total_steps",
      "epochs",
      "steps_per_epoch",
      "pct_start",
      "anneal_strategy",
      "cycle_momentum",
      "base_momentum",
      "max_momentum",
      "div_factor",
      "final_div_factor",
      "three_phase",
      "last_epoch",
      "verbose"
    ],
    "kwargs_change": {
      "max_lr": "max_learning_rate",
      "pct_start": "phase_pct",
      "div_factor": "divide_factor"
    },
    "unsupport_args": [
      "cycle_momentum",
      "base_momentum",
      "max_momentum"
    ]
  },
  "torch.optim.lr_scheduler.ReduceLROnPlateau": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.ReduceOnPlateau",
    "min_input_args": 1,
    "args_list": [
      "optimizer",
      "mode",
      "factor",
      "patience",
      "threshold",
      "threshold_mode",
      "cooldown",
      "min_lr",
      "eps",
      "verbose"
    ],
    "kwargs_change": {
      "eps": "epsilon"
    }
  },
  "torch.optim.lr_scheduler.StepLR": {
    "Matcher": "Optim2LrSchedulerMatcher",
    "paddle_api": "paddle.optimizer.lr.StepDecay",
    "min_input_args": 2,
    "args_list": [
      "optimizer",
      "step_size",
      "gamma",
      "last_epoch",
      "verbose"
    ]
  },
  "torch.outer": {
    "Matcher": "OuterMatcher",
    "paddle_api": "paddle.outer",
    "min_input_args": 2,
    "args_list": [
      "input",
      "vec2",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "vec2": "y"
    }
  },
  "torch.pca_lowrank": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.pca_lowrank",
    "min_input_args": 1,
    "args_list": [
      "A",
      "q",
      "center",
      "niter"
    ],
    "kwargs_change": {
      "A": "x"
    }
  },
  "torch.permute": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dims"
    ],
    "kwargs_change": {
      "input": "x",
      "dims": "perm"
    }
  },
  "torch.pinverse": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.linalg.pinv",
    "min_input_args": 1,
    "args_list": [
      "input",
      "rcond"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.poisson": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.poisson",
    "min_input_args": 1,
    "args_list": [
      "input",
      "generator"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.poisson_nll_loss": {},
  "torch.polar": {
    "Matcher": "PolarMatcher",
    "min_input_args": 2,
    "args_list": [
      "abs",
      "angle",
      "*",
      "out"
    ]
  },
  "torch.pow": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.pow",
    "min_input_args": 2,
    "args_list": [
      "input",
      "exponent",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "exponent": "y"
    }
  },
  "torch.prod": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.prod",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.profiler.profile": {
    "min_input_args": 0
  },
  "torch.profiler.profile.start": {
    "min_input_args": 0
  },
  "torch.profiler.profile.step": {
    "min_input_args": 0
  },
  "torch.profiler.profile.stop": {
    "min_input_args": 0
  },
  "torch.profiler.schedule": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.profiler.make_scheduler",
    "min_input_args": 0,
    "args_list": [
      "*",
      "wait",
      "warmup",
      "active",
      "repeat",
      "skip_first"
    ],
    "kwargs_change": {
      "wait": "closed",
      "warmup": "ready",
      "active": "record"
    }
  },
  "torch.qr": {
    "Matcher": "QrMatcher",
    "paddle_api": "paddle.linalg.qr",
    "min_input_args": 1,
    "args_list": [
      "input",
      "some",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.quantile": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.quantile",
    "args_list": [
      "input",
      "q",
      "dim",
      "keepdim",
      "*",
      "interpolation",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.rad2deg": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.rad2deg",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.rand": {
    "Matcher": "CreateMatcher",
    "paddle_api": "paddle.rand",
    "kwargs_change": {
      "dtype": "dtype"
    },
    "min_input_args": 1,
    "args_list": [
      "*size",
      "generator",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ]
  },
  "torch.rand_like": {
    "Matcher": "RandLikeMatcher",
    "paddle_api": "paddle.rand",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ]
  },
  "torch.randint": {
    "Matcher": "RandintMatcher",
    "paddle_api": "paddle.randint",
    "min_input_args": 2,
    "args_list": [
      "low",
      "high",
      "size",
      "*",
      "generator",
      "out",
      "dtype",
      "layout",
      "device",
      "pin_memory",
      "requires_grad"
    ],
    "kwargs_change": {
      "size": "shape",
      "dtype": "dtype"
    }
  },
  "torch.randint_like": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.randint_like",
    "min_input_args": 3,
    "args_list": [
      "input",
      "low",
      "high",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "torch.randn": {
    "Matcher": "CreateMatcher",
    "paddle_api": "paddle.randn",
    "kwargs_change": {
      "dtype": "dtype"
    },
    "min_input_args": 1,
    "args_list": [
      "*size",
      "generator",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ]
  },
  "torch.randn_like": {
    "Matcher": "RandLikeMatcher",
    "paddle_api": "paddle.randn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ]
  },
  "torch.randperm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.randperm",
    "min_input_args": 1,
    "args_list": [
      "n",
      "*",
      "generator",
      "out",
      "dtype",
      "layout",
      "device",
      "pin_memory",
      "requires_grad"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.range": {
    "Matcher": "RangeMatcher",
    "paddle_api": "paddle.arange",
    "min_input_args": 2,
    "args_list": [
      "start",
      "end",
      "step",
      "*",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ]
  },
  "torch.ravel": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.flatten",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.real": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.real",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.reciprocal": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.reciprocal",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.relu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.relu",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.remainder": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.remainder",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.renorm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.renorm",
    "min_input_args": 4,
    "args_list": [
      "input",
      "p",
      "dim",
      "maxnorm",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "maxnorm": "max_norm"
    }
  },
  "torch.repeat_interleave": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.repeat_interleave",
    "min_input_args": 2,
    "args_list": [
      "input",
      "repeats",
      "dim",
      "*",
      "output_size"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "output_size": ""
    }
  },
  "torch.reshape": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.reshape",
    "min_input_args": 2,
    "args_list": [
      "input",
      "shape"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.roll": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.roll",
    "min_input_args": 2,
    "args_list": [
      "input",
      "shifts",
      "dims"
    ],
    "kwargs_change": {
      "input": "x",
      "dims": "axis"
    }
  },
  "torch.rot90": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.rot90",
    "min_input_args": 1,
    "args_list": [
      "input",
      "k",
      "dims"
    ],
    "kwargs_change": {
      "input": "x",
      "dims": "axes"
    }
  },
  "torch.round": {
    "Matcher": "RoundMatcher",
    "paddle_api": "paddle.round",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "decimals",
      "out"
    ]
  },
  "torch.row_stack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.row_stack",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x"
    }
  },
  "torch.rrelu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.rrelu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "lower",
      "upper",
      "training"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.rsqrt": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.rsqrt",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.save": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.save",
    "min_input_args": 2,
    "args_list": [
      "obj",
      "f",
      "pickle_module",
      "pickle_protocol",
      "_use_new_zipfile_serialization"
    ],
    "kwargs_change": {
      "f": "path",
      "pickle_module": "",
      "pickle_protocol": "protocol",
      "_use_new_zipfile_serialization": ""
    }
  },
  "torch.scalar_tensor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "s",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ],
    "kwargs_change": {
      "s": "data",
      "dtype": "dtype",
      "device": "place"
    },
    "paddle_default_kwargs": {
      "dtype": "paddle.float32"
    }
  },
  "torch.scatter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.put_along_axis",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim",
      "index",
      "value",
      "*",
      "src",
      "reduce",
      "out"
    ],
    "kwargs_change": {
      "input": "arr",
      "dim": "axis",
      "index": "indices",
      "value": "values",
      "src": "values"
    }
  },
  "torch.scatter_add": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.put_along_axis",
    "min_input_args": 4,
    "args_list": [
      "input",
      "dim",
      "index",
      "src"
    ],
    "kwargs_change": {
      "input": "arr",
      "dim": "axis",
      "index": "indices",
      "src": "values"
    },
    "paddle_default_kwargs": {
      "reduce": "'add'"
    }
  },
  "torch.searchsorted": {
    "Matcher": "SearchsortedMatcher",
    "paddle_api": "paddle.searchsorted",
    "min_input_args": 2,
    "args_list": [
      "sorted_sequence",
      "input",
      "*",
      "out_int32",
      "right",
      "side",
      "sorter",
      "out"
    ],
    "kwargs_change": {
      "input": "values"
    }
  },
  "torch.seed": {
    "Matcher": "SeedMatcher",
    "min_input_args": 0
  },
  "torch.select": {
    "Matcher": "SelectMatcher",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim",
      "index"
    ]
  },
  "torch.select_scatter": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.select_scatter",
    "min_input_args": 4,
    "args_list": [
      "input",
      "src",
      "dim",
      "index"
    ],
    "kwargs_change": {
      "input": "x",
      "src": "values",
      "dim": "axis"
    }
  },
  "torch.selu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.selu",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.set_default_dtype": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_default_dtype",
    "min_input_args": 1,
    "args_list": [
      "d"
    ]
  },
  "torch.set_default_tensor_type": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_default_dtype",
    "args_list": [
      "d"
    ]
  },
  "torch.set_grad_enabled": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_grad_enabled",
    "min_input_args": 1,
    "args_list": [
      "mode"
    ]
  },
  "torch.set_printoptions": {
    "Matcher": "SetPrintOptionsMatcher",
    "paddle_api": "paddle.set_printoptions",
    "min_input_args": 0,
    "args_list": [
      "precision",
      "threshold",
      "edgeitems",
      "linewidth",
      "profile",
      "sci_mode"
    ],
    "paddle_default_kwargs": {
      "precision": 4
    }
  },
  "torch.set_rng_state": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.set_rng_state",
    "min_input_args": 1,
    "args_list": [
      "new_state"
    ],
    "kwargs_change": {
      "new_state": "state_list"
    }
  },
  "torch.sgn": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sgn",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.sign": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sign",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.signbit": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.signbit",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.sin": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sin",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.sinh": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sinh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.slogdet": {
    "Matcher": "SLogDetMatcher",
    "paddle_api": "paddle.linalg.slogdet",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.softmax": {
    "Matcher": "RequireDimMatcher",
    "paddle_api": "paddle.nn.functional.softmax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.solve": {
    "min_input_args": 2
  },
  "torch.sort": {
    "Matcher": "SortMatcher",
    "paddle_api": "paddle.sort",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "descending",
      "*",
      "stable",
      "dim",
      "descending",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "stable": ""
    }
  },
  "torch.sparse.addmm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sparse.addmm",
    "min_input_args": 3,
    "args_list": [
      "input",
      "mat1",
      "mat2",
      "*",
      "beta",
      "alpha"
    ],
    "kwargs_change": {
      "mat1": "x",
      "mat2": "y"
    }
  },
  "torch.sparse.mm": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sparse.matmul",
    "min_input_args": 2,
    "args_list": [
      "sparse",
      "dense"
    ],
    "kwargs_change": {
      "sparse": "x",
      "dense": "y"
    }
  },
  "torch.sparse.softmax": {
    "Matcher": "SparseSoftmaxMatcher",
    "paddle_api": "paddle.sparse.nn.functional.softmax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.sparse.sum": {
    "Matcher": "RequireDimMatcher",
    "paddle_api": "paddle.sparse.sum",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "unsupport_args": [
      "dtype"
    ]
  },
  "torch.sparse_coo_tensor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sparse.sparse_coo_tensor",
    "min_input_args": 2,
    "args_list": [
      "indices",
      "values",
      "size",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "check_invariants"
    ],
    "kwargs_change": {
      "size": "shape",
      "dtype": "dtype",
      "device": "place",
      "check_invariants": ""
    }
  },
  "torch.sparse_csr_tensor": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sparse.sparse_csr_tensor",
    "min_input_args": 3,
    "args_list": [
      "crow_indices",
      "col_indices",
      "values",
      "size",
      "*",
      "dtype",
      "layout",
      "device",
      "pin_memory",
      "requires_grad",
      "check_invariants"
    ],
    "kwargs_change": {
      "crow_indices": "crows",
      "col_indices": "cols",
      "size": "shape",
      "dtype": "dtype",
      "device": "place",
      "pin_memory": "",
      "check_invariants": ""
    }
  },
  "torch.special.airy_ai": {},
  "torch.special.bessel_j0": {},
  "torch.special.bessel_j1": {},
  "torch.special.bessel_y0": {},
  "torch.special.bessel_y1": {},
  "torch.special.digamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.digamma",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.entr": {},
  "torch.special.erf": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.erf",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.erfc": {
    "Matcher": "ErfCMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.erfcx": {
    "Matcher": "SpecialErfcxMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.special.erfinv": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.erfinv",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.exp2": {
    "Matcher": "Exp2Matcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.special.expit": {
    "Matcher": "ExpitMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.special.expm1": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.expm1",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.gammainc": {},
  "torch.special.gammaincc": {},
  "torch.special.gammaln": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.lgamma",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.i0": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.i0",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.i0e": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.i0e",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.i1": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.i1",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.i1e": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.i1e",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.log1p": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.log1p",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.log_ndtr": {},
  "torch.special.log_softmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.log_softmax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.special.logit": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logit",
    "min_input_args": 1,
    "args_list": [
      "input",
      "eps",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.logsumexp": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.logsumexp",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.special.multigammaln": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.multigammaln",
    "min_input_args": 2,
    "args_list": [
      "input",
      "p",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.ndtr": {},
  "torch.special.ndtri": {
    "Matcher": "SpecialNdtriMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.special.polygamma": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.polygamma",
    "min_input_args": 2,
    "args_list": [
      "n",
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.psi": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.digamma",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.special.round": {
    "Matcher": "RoundMatcher",
    "paddle_api": "paddle.round",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "decimals",
      "out"
    ]
  },
  "torch.special.scaled_modified_bessel_k0": {},
  "torch.special.scaled_modified_bessel_k1": {},
  "torch.special.sinc": {
    "Matcher": "SincMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.special.softmax": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.nn.functional.softmax",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim",
      "*",
      "dtype"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.special.spherical_bessel_j0": {},
  "torch.special.xlog1py": {
    "Matcher": "SpecialXLog1pYMatcher",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.special.xlogy": {
    "Matcher": "XLogYMatcher",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ]
  },
  "torch.special.zeta": {},
  "torch.split": {
    "Matcher": "SplitMatcher",
    "paddle_api": "paddle.split",
    "min_input_args": 2,
    "args_list": [
      "tensor",
      "split_size_or_sections",
      "dim"
    ],
    "kwargs_change": {
      "tensor": "x",
      "split_size_or_sections": "num_or_sections",
      "dim": "axis"
    }
  },
  "torch.sqrt": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sqrt",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.square": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.square",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.squeeze": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.squeeze",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.stack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.stack",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x",
      "dim": "axis"
    }
  },
  "torch.std": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.std",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.std_mean": {
    "Matcher": "StdMeanMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.subtract": {
    "Matcher": "Num2TensorBinaryWithAlphaMatcher",
    "paddle_api": "paddle.subtract",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "alpha",
      "out"
    ]
  },
  "torch.sum": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.sum",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "keepdim",
      "*",
      "dtype",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "dtype": "dtype"
    }
  },
  "torch.svd": {
    "Matcher": "SvdMatcher",
    "paddle_api": "paddle.linalg.svd",
    "args_list": [
      "input",
      "some",
      "compute_uv",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    },
    "unsupport_args": [
      "compute_uv"
    ]
  },
  "torch.swapaxes": {
    "Matcher": "SwapAxesMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 3,
    "args_list": [
      "input",
      "axis0",
      "axis1"
    ]
  },
  "torch.swapdims": {
    "Matcher": "TransposeMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim0",
      "dim1"
    ]
  },
  "torch.symeig": {
    "Matcher": "SymeigMatcher",
    "paddle_api": "paddle.linalg.eigh",
    "min_input_args": 1,
    "args_list": [
      "input",
      "eigenvectors",
      "upper",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.t": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.t",
    "min_input_args": 1,
    "args_list": [
      "input"
    ]
  },
  "torch.take": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.take",
    "min_input_args": 2,
    "args_list": [
      "input",
      "index"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.take_along_dim": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.take_along_axis",
    "min_input_args": 3,
    "args_list": [
      "input",
      "indices",
      "dim",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "arr",
      "dim": "axis"
    }
  },
  "torch.tan": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.tan",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.tensor": {
    "Matcher": "TorchTensorMatcher",
    "paddle_api": "paddle.to_tensor",
    "min_input_args": 1,
    "args_list": [
      "data",
      "*",
      "dtype",
      "device",
      "requires_grad",
      "pin_memory"
    ]
  },
  "torch.tensordot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.tensordot",
    "min_input_args": 2,
    "args_list": [
      "a",
      "b",
      "dims",
      "out"
    ],
    "kwargs_change": {
      "a": "x",
      "b": "y",
      "dims": "axes"
    }
  },
  "torch.testing.assert_allclose": {
    "Matcher": "Assert_AllcloseMatcher",
    "paddle_api": "paddle.allclose",
    "min_input_args": 2,
    "args_list": [
      "actual",
      "expected",
      "rtol",
      "atol",
      "equal_nan",
      "msg"
    ],
    "kwargs_change": {
      "expected": "y",
      "acltual": "x"
    }
  },
  "torch.testing.assert_close": {
    "Matcher": "Assert_AllcloseMatcher",
    "paddle_api": "paddle.allclose",
    "min_input_args": 2,
    "args_list": [
      "actual",
      "expected",
      "*",
      "allow_subclasses",
      "rtol",
      "atol",
      "equal_nan",
      "check_device",
      "check_dtype",
      "check_layout",
      "check_stride",
      "msg"
    ],
    "kwargs_change": {
      "actual": "x",
      "expected": "y",
      "allow_subclasses": "",
      "check_device": "",
      "check_dtype": "",
      "check_layout": "",
      "check_stride": ""
    }
  },
  "torch.tile": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.tile",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dims"
    ],
    "kwargs_change": {
      "input": "x",
      "dims": "repeat_times"
    }
  },
  "torch.topk": {
    "Matcher": "DoubleAssignMatcher",
    "paddle_api": "paddle.topk",
    "min_input_args": 2,
    "args_list": [
      "input",
      "k",
      "dim",
      "largest",
      "sorted",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.trace": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.trace",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.transpose": {
    "Matcher": "TransposeMatcher",
    "paddle_api": "paddle.transpose",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim0",
      "dim1"
    ]
  },
  "torch.trapezoid": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.trapezoid",
    "args_list": [
      "y",
      "x",
      "dx",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.triangular_solve": {
    "Matcher": "TriangularSolveMatcher",
    "paddle_api": "paddle.linalg.triangular_solve",
    "min_input_args": 2,
    "args_list": [
      "input",
      "A",
      "upper",
      "transpose",
      "unitriangular",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "y",
      "A": "x"
    }
  },
  "torch.tril": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.tril",
    "min_input_args": 1,
    "args_list": [
      "input",
      "diagonal",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.tril_indices": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.tril_indices",
    "min_input_args": 2,
    "args_list": [
      "row",
      "col",
      "offset",
      "*",
      "dtype",
      "device",
      "layout"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.triplet_margin_loss": {},
  "torch.triu": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.triu",
    "min_input_args": 1,
    "args_list": [
      "input",
      "diagonal",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.triu_indices": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.triu_indices",
    "min_input_args": 2,
    "args_list": [
      "row",
      "col",
      "offset",
      "*",
      "dtype",
      "device",
      "layout"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.true_divide": {
    "Matcher": "Num2TensorBinaryMatcher",
    "paddle_api": "paddle.divide",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.trunc": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.trunc",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "out"
    ]
  },
  "torch.unbind": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.unbind",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "dim": "axis"
    }
  },
  "torch.unflatten": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.unflatten",
    "min_input_args": 3,
    "args_list": [
      "input",
      "dim",
      "sizes"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "sizes": "shape"
    }
  },
  "torch.unique": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.unique",
    "min_input_args": 1,
    "args_list": [
      "input",
      "sorted",
      "return_inverse",
      "return_counts",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "unsupport_args": [
      "sorted"
    ]
  },
  "torch.unique_consecutive": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.unique_consecutive",
    "args_list": [
      "input",
      "return_inverse",
      "return_counts",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    },
    "min_input_args": 0
  },
  "torch.unsqueeze": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.unsqueeze",
    "min_input_args": 2,
    "args_list": [
      "input",
      "dim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis"
    }
  },
  "torch.utils.cpp_extension.BuildExtension": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.cpp_extension.BuildExtension",
    "args_list": [
      "dist"
    ],
    "min_input_args": 0
  },
  "torch.utils.cpp_extension.CUDAExtension": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.cpp_extension.CUDAExtension",
    "args_list": [
      "name",
      "sources",
      "*",
      "include_dirs",
      "define_macros",
      "undef_macros",
      "library_dirs",
      "libraries",
      "runtime_library_dirs",
      "extra_objects",
      "extra_compile_args",
      "extra_link_args",
      "export_symbols",
      "swig_opts",
      "depends",
      "language",
      "optional",
      "py_limited_api"
    ],
    "kwargs_change": {
      "name": ""
    },
    "min_input_args": 2
  },
  "torch.utils.cpp_extension.CppExtension": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.cpp_extension.CppExtension",
    "args_list": [
      "name",
      "sources",
      "*",
      "include_dirs",
      "define_macros",
      "undef_macros",
      "library_dirs",
      "libraries",
      "runtime_library_dirs",
      "extra_objects",
      "extra_compile_args",
      "extra_link_args",
      "export_symbols",
      "swig_opts",
      "depends",
      "language",
      "optional",
      "py_limited_api"
    ],
    "kwargs_change": {
      "name": ""
    },
    "min_input_args": 2
  },
  "torch.utils.cpp_extension.load": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.cpp_extension.load",
    "args_list": [
      "name",
      "sources",
      "extra_cflags",
      "extra_cuda_cflags",
      "extra_ldflags",
      "extra_include_paths",
      "build_directory",
      "verbose",
      "with_cuda",
      "is_python_module",
      "is_standalone",
      "keep_intermediates"
    ],
    "kwargs_change": {
      "extra_cflags": "extra_cxx_cflags",
      "with_cuda": "",
      "keep_intermediates": ""
    },
    "unsupport_args": [
      "is_python_module",
      "is_standalone"
    ],
    "min_input_args": 2
  },
  "torch.utils.data.BatchSampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.BatchSampler",
    "min_input_args": 3,
    "args_list": [
      "sampler",
      "batch_size",
      "drop_last"
    ]
  },
  "torch.utils.data.ChainDataset": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.ChainDataset",
    "min_input_args": 1,
    "args_list": [
      "datasets"
    ]
  },
  "torch.utils.data.ConcatDataset": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.ConcatDataset",
    "min_input_args": 1,
    "args_list": [
      "datasets"
    ]
  },
  "torch.utils.data.DataLoader": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.DataLoader",
    "min_input_args": 1,
    "args_list": [
      "dataset",
      "batch_size",
      "shuffle",
      "sampler",
      "batch_sampler",
      "num_workers",
      "collate_fn",
      "pin_memory",
      "drop_last",
      "timeout",
      "worker_init_fn",
      "multiprocessing_context",
      "generator",
      "prefetch_factor",
      "persistent_workers",
      "pin_memory_device"
    ],
    "kwargs_change": {
      "pin_memory": "",
      "multiprocessing_context": "",
      "generator": "",
      "persistent_workers": "",
      "pin_memory_device": ""
    },
    "unsupport_args": [
      "sampler",
      "prefetch_factor"
    ]
  },
  "torch.utils.data.Dataset": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.Dataset",
    "abstract": true,
    "min_input_args": 0
  },
  "torch.utils.data.DistributedSampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.DistributedBatchSampler",
    "min_input_args": 1,
    "args_list": [
      "dataset",
      "num_replicas",
      "rank",
      "shuffle",
      "seed",
      "drop_last"
    ],
    "kwargs_change": {
      "seed": ""
    },
    "paddle_default_kwargs": {
      "shuffle": "True",
      "batch_size": "1"
    }
  },
  "torch.utils.data.IterableDataset": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.IterableDataset",
    "abstract": true,
    "min_input_args": 0
  },
  "torch.utils.data.RandomSampler": {
    "Matcher": "RandomSamplerMatcher",
    "paddle_api": "paddle.io.RandomSampler",
    "min_input_args": 1,
    "args_list": [
      "data_source",
      "replacement",
      "num_samples",
      "generator"
    ]
  },
  "torch.utils.data.Sampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.Sampler",
    "args_list": [
      "data_source"
    ],
    "min_input_args": 0
  },
  "torch.utils.data.SequentialSampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.SequenceSampler",
    "args_list": [
      "data_source"
    ],
    "min_input_args": 0
  },
  "torch.utils.data.Subset": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.Subset",
    "min_input_args": 2,
    "args_list": [
      "dataset",
      "indices"
    ]
  },
  "torch.utils.data.SubsetRandomSampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.SubsetRandomSampler",
    "min_input_args": 1,
    "args_list": [
      "indices",
      "generator"
    ]
  },
  "torch.utils.data.TensorDataset": {
    "Matcher": "TensorDatasetMatcher",
    "paddle_api": "paddle.io.TensorDataset",
    "min_input_args": 1,
    "args_list": [
      "*tensors"
    ]
  },
  "torch.utils.data.WeightedRandomSampler": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.WeightedRandomSampler",
    "min_input_args": 2,
    "args_list": [
      "weights",
      "num_samples",
      "replacement",
      "generator"
    ]
  },
  "torch.utils.data.default_collate": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.dataloader.collate.default_collate_fn",
    "min_input_args": 1,
    "args_list": [
      "batch"
    ]
  },
  "torch.utils.data.get_worker_info": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.get_worker_info",
    "min_input_args": 0
  },
  "torch.utils.data.random_split": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.io.random_split",
    "min_input_args": 2,
    "args_list": [
      "dataset",
      "lengths",
      "generator"
    ]
  },
  "torch.utils.dlpack.from_dlpack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.dlpack.from_dlpack",
    "min_input_args": 1,
    "args_list": [
      "ext_tensor"
    ],
    "kwargs_change": {
      "ext_tensor": "dlpack"
    }
  },
  "torch.utils.dlpack.to_dlpack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.utils.dlpack.to_dlpack",
    "args_list": [
      "tensor"
    ],
    "kwargs_change": {
      "tensor": "x"
    }
  },
  "torch.vander": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.vander",
    "min_input_args": 1,
    "args_list": [
      "x",
      "N",
      "increasing"
    ],
    "kwargs_change": {
      "N": "n"
    }
  },
  "torch.var": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.var",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.var_mean": {
    "Matcher": "VarMeanMatcher",
    "min_input_args": 1,
    "args_list": [
      "input",
      "dim",
      "unbiased",
      "keepdim",
      "*",
      "correction",
      "keepdim"
    ],
    "kwargs_change": {
      "input": "x",
      "dim": "axis",
      "correction": "unbiased"
    }
  },
  "torch.vdot": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.dot",
    "min_input_args": 2,
    "args_list": [
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.view_as_complex": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.as_complex",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.view_as_real": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.as_real",
    "min_input_args": 1,
    "args_list": [
      "input"
    ],
    "kwargs_change": {
      "input": "x"
    }
  },
  "torch.vstack": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.vstack",
    "min_input_args": 1,
    "args_list": [
      "tensors",
      "*",
      "out"
    ],
    "kwargs_change": {
      "tensors": "x"
    }
  },
  "torch.where": {
    "Matcher": "WhereMatcher",
    "paddle_api": "paddle.where",
    "min_input_args": 3,
    "args_list": [
      "condition",
      "input",
      "other",
      "*",
      "out"
    ],
    "kwargs_change": {
      "input": "x",
      "other": "y"
    }
  },
  "torch.zeros": {
    "Matcher": "CreateMatcher",
    "paddle_api": "paddle.zeros",
    "min_input_args": 1,
    "args_list": [
      "*size",
      "out",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ],
    "kwargs_change": {
      "dtype": "dtype"
    }
  },
  "torch.zeros_like": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddle.zeros_like",
    "min_input_args": 1,
    "args_list": [
      "input",
      "*",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "memory_format"
    ],
    "kwargs_change": {
      "input": "x",
      "dtype": "dtype"
    }
  },
  "transformers.AddedToken": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddlenlp.transformers.AddedToken",
    "args_list": [
      "content",
      "single_word",
      "lstrip",
      "rstrip",
      "normalized"
    ]
  },
  "transformers.GenerationConfig": {
    "Matcher": "TRFMGenerationConfigMatcher",
    "paddle_api": "paddlenlp.generation.GenerationConfig",
    "args_list": [
      "*",
      "max_length",
      "max_new_tokens",
      "min_length",
      "min_new_tokens",
      "early_stopping",
      "max_time",
      "do_sample",
      "num_beams",
      "num_beam_groups",
      "penalty_alpha",
      "use_cache",
      "temperature",
      "top_k",
      "top_p",
      "typical_p",
      "epsilon_cutoff",
      "eta_cutoff",
      "diversity_penalty",
      "repetition_penalty",
      "encoder_repetition_penalty",
      "length_penalty",
      "no_repeat_ngram_size",
      "bad_words_ids",
      "force_words_ids",
      "renormalize_logits",
      "constraints",
      "forced_bos_token_id",
      "forced_eos_token_id",
      "remove_invalid_values",
      "exponential_decay_length_penalty",
      "suppress_tokens",
      "begin_suppress_tokens",
      "forced_decoder_ids",
      "sequence_bias ",
      "guidance_scale",
      "low_memory",
      "num_return_sequences",
      "output_attentions",
      "output_hidden_states",
      "output_scores",
      "return_dict_in_generate",
      "pad_token_id",
      "bos_token_id",
      "eos_token_id",
      "encoder_no_repeat_ngram_size",
      "decoder_start_token_id",
      "num_assistant_tokens",
      "num_assistant_tokens_schedule"
    ],
    "unsupport_args": [
      "max_new_tokens",
      "min_new_tokens",
      "max_time",
      "penalty_alpha",
      "typical_p",
      "epsilon_cutoff",
      "eta_cutoff",
      "diversity_penalty",
      "encoder_repetition_penalty",
      "no_repeat_ngram_size",
      "bad_words_ids",
      "force_words_ids",
      "renormalize_logits",
      "constraints",
      "remove_invalid_values",
      "exponential_decay_length_penalty",
      "suppress_tokens",
      "begin_suppress_tokens",
      "forced_decoder_ids",
      "sequence_bias ",
      "guidance_scale",
      "low_memory",
      "num_return_sequences",
      "output_attentions",
      "output_hidden_states",
      "output_scores",
      "return_dict_in_generate",
      "encoder_no_repeat_ngram_size",
      "num_assistant_tokens",
      "num_assistant_tokens_schedule"
    ]
  },
  "transformers.logging.get_logger": {
    "Matcher": "TRFMGetLoggerMatcher",
    "args_list": [
      "name"
    ]
  },
  "transformers.modeling_outputs.BaseModelOutputWithPast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddlenlp.transformers.model_outputs.BaseModelOutputWithPast",
    "args_list": [
      "last_hidden_state",
      "past_key_values",
      "hidden_states",
      "attentions"
    ]
  },
  "transformers.modeling_outputs.CausalLMOutputWithPast": {
    "Matcher": "GenericMatcher",
    "paddle_api": "paddlenlp.transformers.model_outputs.CausalLMOutputWithPast",
    "args_list": [
      "loss",
      "logits",
      "past_key_values",
      "hidden_states",
      "attentions"
    ]
  }
}
